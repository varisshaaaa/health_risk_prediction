{"ast":null,"code":"import { addDomEvent, AnimationFrame, raf, contains, dataAttr, MAX_Z_INDEX } from '@zag-js/dom-query';\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { setup, createGuards, createMachine as createMachine$1 } from '@zag-js/core';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\nimport { uuid, setRafTimeout, ensureProps, warn, runIfFn, compact } from '@zag-js/utils';\n\n// src/toast-group.connect.ts\nvar anatomy = createAnatomy(\"toast\").parts(\"group\", \"root\", \"title\", \"description\", \"actionTrigger\", \"closeTrigger\");\nvar parts = anatomy.build();\n\n// src/toast.dom.ts\nvar getRegionId = placement => `toast-group:${placement}`;\nvar getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);\nvar getRootId = ctx => `toast:${ctx.id}`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getTitleId = ctx => `toast:${ctx.id}:title`;\nvar getDescriptionId = ctx => `toast:${ctx.id}:description`;\nvar getCloseTriggerId = ctx => `toast${ctx.id}:close`;\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nvar getOffsets = offsets => typeof offsets === \"string\" ? {\n  left: offsets,\n  right: offsets,\n  bottom: offsets,\n  top: offsets\n} : offsets;\nfunction getGroupPlacementStyle(service, placement) {\n  const {\n    prop,\n    computed,\n    context\n  } = service;\n  const {\n    offsets,\n    gap\n  } = prop(\"store\").attrs;\n  const heights = context.get(\"heights\");\n  const computedOffset = getOffsets(offsets);\n  const rtl = prop(\"dir\") === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: computed(\"count\") > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${gap}px`,\n    \"--first-height\": `${heights[0]?.height || 0}px`,\n    \"--viewport-offset-left\": computedOffset.left,\n    \"--viewport-offset-right\": computedOffset.right,\n    \"--viewport-offset-top\": computedOffset.top,\n    \"--viewport-offset-bottom\": computedOffset.bottom,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(service, visible) {\n  const {\n    prop,\n    context,\n    computed\n  } = service;\n  const parent = prop(\"parent\");\n  const placement = parent.computed(\"placement\");\n  const {\n    gap\n  } = parent.prop(\"store\").attrs;\n  const [side] = placement.split(\"-\");\n  const mounted = context.get(\"mounted\");\n  const remainingTime = context.get(\"remainingTime\");\n  const height = computed(\"height\");\n  const frontmost = computed(\"frontmost\");\n  const sibling = !frontmost;\n  const overlap = !prop(\"stacked\");\n  const stacked = prop(\"stacked\");\n  const type = prop(\"type\");\n  const duration = type === \"loading\" ? Number.MAX_SAFE_INTEGER : remainingTime;\n  const offset = computed(\"heightIndex\") * gap + computed(\"heightBefore\");\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${prop(\"removeDelay\")}ms`,\n    \"--duration\": `${duration}ms`,\n    \"--initial-height\": `${height}px`,\n    \"--offset\": `${offset}px`,\n    \"--index\": prop(\"index\"),\n    \"--z-index\": computed(\"zIndex\"),\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(service, visible) {\n  const {\n    computed\n  } = service;\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (computed(\"frontmost\") && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle() {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(service, normalize) {\n  const {\n    context,\n    prop,\n    send,\n    refs,\n    computed\n  } = service;\n  return {\n    getCount() {\n      return context.get(\"toasts\").length;\n    },\n    getToasts() {\n      return context.get(\"toasts\");\n    },\n    getGroupProps(options = {}) {\n      const {\n        label = \"Notifications\"\n      } = options;\n      const {\n        hotkey\n      } = prop(\"store\").attrs;\n      const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const placement = computed(\"placement\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: prop(\"dir\"),\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(service, placement),\n        onMouseEnter() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseMove() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseLeave() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({\n            type: \"REGION.POINTER_LEAVE\",\n            placement\n          });\n        },\n        onFocus(event) {\n          send({\n            type: \"REGION.FOCUS\",\n            target: event.relatedTarget\n          });\n        },\n        onBlur(event) {\n          if (refs.get(\"isFocusWithin\") && !contains(event.currentTarget, event.relatedTarget)) {\n            queueMicrotask(() => send({\n              type: \"REGION.BLUR\"\n            }));\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const store = prop(\"store\");\n      return store.subscribe(() => fn(context.get(\"toasts\")));\n    }\n  };\n}\nvar {\n  guards,\n  createMachine\n} = setup();\nvar {\n  and\n} = guards;\nvar groupMachine = createMachine({\n  props({\n    props\n  }) {\n    return {\n      dir: \"ltr\",\n      id: uuid(),\n      ...props,\n      store: props.store\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"store\").attrs.overlap ? \"overlap\" : \"stack\";\n  },\n  refs() {\n    return {\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      isPointerWithin: false,\n      ignoreMouseTimer: AnimationFrame.create(),\n      dismissableCleanup: void 0\n    };\n  },\n  context({\n    bindable\n  }) {\n    return {\n      toasts: bindable(() => ({\n        defaultValue: [],\n        sync: true,\n        hash: toasts => toasts.map(t => t.id).join(\",\")\n      })),\n      heights: bindable(() => ({\n        defaultValue: [],\n        sync: true\n      }))\n    };\n  },\n  computed: {\n    count: ({\n      context\n    }) => context.get(\"toasts\").length,\n    overlap: ({\n      prop\n    }) => prop(\"store\").attrs.overlap,\n    placement: ({\n      prop\n    }) => prop(\"store\").attrs.placement\n  },\n  effects: [\"subscribeToStore\", \"trackDocumentVisibility\", \"trackHotKeyPress\"],\n  watch({\n    track,\n    context,\n    action\n  }) {\n    track([() => context.hash(\"toasts\")], () => {\n      queueMicrotask(() => {\n        action([\"collapsedIfEmpty\", \"setDismissableBranch\"]);\n      });\n    });\n  },\n  exit: [\"clearDismissableBranch\", \"clearLastFocusedEl\", \"clearMouseEventTimer\"],\n  on: {\n    \"DOC.HOTKEY\": {\n      actions: [\"focusRegionEl\"]\n    },\n    \"REGION.BLUR\": [{\n      guard: and(\"isOverlapping\", \"isPointerOut\"),\n      target: \"overlap\",\n      actions: [\"collapseToasts\", \"resumeToasts\", \"restoreFocusIfPointerOut\"]\n    }, {\n      guard: \"isPointerOut\",\n      target: \"stack\",\n      actions: [\"resumeToasts\", \"restoreFocusIfPointerOut\"]\n    }, {\n      actions: [\"clearFocusWithin\"]\n    }],\n    \"TOAST.REMOVE\": {\n      actions: [\"removeToast\", \"removeHeight\", \"ignoreMouseEventsTemporarily\"]\n    },\n    \"TOAST.PAUSE\": {\n      actions: [\"pauseToasts\"]\n    }\n  },\n  states: {\n    stack: {\n      on: {\n        \"REGION.POINTER_LEAVE\": [{\n          guard: \"isOverlapping\",\n          target: \"overlap\",\n          actions: [\"clearPointerWithin\", \"resumeToasts\", \"collapseToasts\"]\n        }, {\n          actions: [\"clearPointerWithin\", \"resumeToasts\"]\n        }],\n        \"REGION.OVERLAP\": {\n          target: \"overlap\",\n          actions: [\"collapseToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          actions: [\"setPointerWithin\", \"pauseToasts\"]\n        }\n      }\n    },\n    overlap: {\n      on: {\n        \"REGION.STACK\": {\n          target: \"stack\",\n          actions: [\"expandToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          target: \"stack\",\n          actions: [\"setPointerWithin\", \"pauseToasts\", \"expandToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          target: \"stack\",\n          actions: [\"setLastFocusedEl\", \"pauseToasts\", \"expandToasts\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOverlapping: ({\n        computed\n      }) => computed(\"overlap\"),\n      isPointerOut: ({\n        refs\n      }) => !refs.get(\"isPointerWithin\")\n    },\n    effects: {\n      subscribeToStore({\n        context,\n        prop\n      }) {\n        return prop(\"store\").subscribe(toast => {\n          if (toast.dismiss) {\n            context.set(\"toasts\", prev => prev.filter(t => t.id !== toast.id));\n            return;\n          }\n          context.set(\"toasts\", prev => {\n            const index = prev.findIndex(t => t.id === toast.id);\n            if (index !== -1) {\n              return [...prev.slice(0, index), {\n                ...prev[index],\n                ...toast\n              }, ...prev.slice(index + 1)];\n            }\n            return [toast, ...prev];\n          });\n        });\n      },\n      trackHotKeyPress({\n        prop,\n        send\n      }) {\n        const handleKeyDown = event => {\n          const {\n            hotkey\n          } = prop(\"store\").attrs;\n          const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({\n            type: \"DOC.HOTKEY\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, {\n          capture: true\n        });\n      },\n      trackDocumentVisibility({\n        prop,\n        send,\n        scope\n      }) {\n        const {\n          pauseOnPageIdle\n        } = prop(\"store\").attrs;\n        if (!pauseOnPageIdle) return;\n        const doc = scope.getDoc();\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          const isHidden = doc.visibilityState === \"hidden\";\n          send({\n            type: isHidden ? \"PAUSE_ALL\" : \"RESUME_ALL\"\n          });\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch({\n        refs,\n        context,\n        computed,\n        scope\n      }) {\n        const toasts = context.get(\"toasts\");\n        const placement = computed(\"placement\");\n        const hasToasts = toasts.length > 0;\n        if (!hasToasts) {\n          refs.get(\"dismissableCleanup\")?.();\n          return;\n        }\n        if (hasToasts && refs.get(\"dismissableCleanup\")) {\n          return;\n        }\n        const groupEl = () => getRegionEl(scope, placement);\n        const cleanup = trackDismissableBranch(groupEl, {\n          defer: true\n        });\n        refs.set(\"dismissableCleanup\", cleanup);\n      },\n      clearDismissableBranch({\n        refs\n      }) {\n        refs.get(\"dismissableCleanup\")?.();\n      },\n      focusRegionEl({\n        scope,\n        computed\n      }) {\n        queueMicrotask(() => {\n          getRegionEl(scope, computed(\"placement\"))?.focus();\n        });\n      },\n      pauseToasts({\n        prop\n      }) {\n        prop(\"store\").pause();\n      },\n      resumeToasts({\n        prop\n      }) {\n        prop(\"store\").resume();\n      },\n      expandToasts({\n        prop\n      }) {\n        prop(\"store\").expand();\n      },\n      collapseToasts({\n        prop\n      }) {\n        prop(\"store\").collapse();\n      },\n      removeToast({\n        prop,\n        event\n      }) {\n        prop(\"store\").remove(event.id);\n      },\n      removeHeight({\n        event,\n        context\n      }) {\n        if (event?.id == null) return;\n        queueMicrotask(() => {\n          context.set(\"heights\", heights => heights.filter(height => height.id !== event.id));\n        });\n      },\n      collapsedIfEmpty({\n        send,\n        computed\n      }) {\n        if (!computed(\"overlap\") || computed(\"count\") > 1) return;\n        send({\n          type: \"REGION.OVERLAP\"\n        });\n      },\n      setLastFocusedEl({\n        refs,\n        event\n      }) {\n        if (refs.get(\"isFocusWithin\") || !event.target) return;\n        refs.set(\"isFocusWithin\", true);\n        refs.set(\"lastFocusedEl\", event.target);\n      },\n      restoreFocusIfPointerOut({\n        refs\n      }) {\n        if (!refs.get(\"lastFocusedEl\") || refs.get(\"isPointerWithin\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({\n          preventScroll: true\n        });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      },\n      setPointerWithin({\n        refs\n      }) {\n        refs.set(\"isPointerWithin\", true);\n      },\n      clearPointerWithin({\n        refs\n      }) {\n        refs.set(\"isPointerWithin\", false);\n        if (refs.get(\"lastFocusedEl\") && !refs.get(\"isFocusWithin\")) {\n          refs.get(\"lastFocusedEl\")?.focus({\n            preventScroll: true\n          });\n          refs.set(\"lastFocusedEl\", null);\n        }\n      },\n      clearFocusWithin({\n        refs\n      }) {\n        refs.set(\"isFocusWithin\", false);\n      },\n      clearLastFocusedEl({\n        refs\n      }) {\n        if (!refs.get(\"lastFocusedEl\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({\n          preventScroll: true\n        });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      },\n      ignoreMouseEventsTemporarily({\n        refs\n      }) {\n        refs.get(\"ignoreMouseTimer\").request();\n      },\n      clearMouseEventTimer({\n        refs\n      }) {\n        refs.get(\"ignoreMouseTimer\").cancel();\n      }\n    }\n  }\n});\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    scope,\n    context,\n    computed\n  } = service;\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const mounted = context.get(\"mounted\");\n  const frontmost = computed(\"frontmost\");\n  const placement = prop(\"parent\").computed(\"placement\");\n  const type = prop(\"type\");\n  const stacked = prop(\"stacked\");\n  const title = prop(\"title\");\n  const description = prop(\"description\");\n  const action = prop(\"action\");\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title,\n    description,\n    placement,\n    visible,\n    paused,\n    closable: !!prop(\"closable\"),\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    dismiss() {\n      send({\n        type: \"DISMISS\",\n        src: \"programmatic\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(frontmost),\n        \"data-sibling\": dataAttr(!frontmost),\n        \"data-stack\": dataAttr(stacked),\n        \"data-overlap\": dataAttr(!stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": description ? getDescriptionId(scope) : void 0,\n        \"aria-labelledby\": title ? getTitleId(scope) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(service, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send({\n              type: \"DISMISS\",\n              src: \"keyboard\"\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(service, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle()\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: getDescriptionId(scope)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          action?.onClick?.();\n          send({\n            type: \"DISMISS\",\n            src: \"user\"\n          });\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: getCloseTriggerId(scope),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"DISMISS\",\n            src: \"user\"\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = createGuards();\nvar machine = createMachine$1({\n  props({\n    props\n  }) {\n    ensureProps(props, [\"id\", \"type\", \"parent\", \"removeDelay\"], \"toast\");\n    return {\n      closable: true,\n      ...props,\n      duration: getToastDuration(props.duration, props.type)\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const persist = prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity;\n    return persist ? \"visible:persist\" : \"visible\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      remainingTime: bindable(() => ({\n        defaultValue: getToastDuration(prop(\"duration\"), prop(\"type\"))\n      })),\n      createdAt: bindable(() => ({\n        defaultValue: Date.now()\n      })),\n      mounted: bindable(() => ({\n        defaultValue: false\n      })),\n      initialHeight: bindable(() => ({\n        defaultValue: 0\n      }))\n    };\n  },\n  refs() {\n    return {\n      closeTimerStartTime: Date.now(),\n      lastCloseStartTimerStartTime: 0\n    };\n  },\n  computed: {\n    zIndex: ({\n      prop\n    }) => {\n      const toasts = prop(\"parent\").context.get(\"toasts\");\n      const index = toasts.findIndex(toast => toast.id === prop(\"id\"));\n      return toasts.length - index;\n    },\n    height: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const height = heights.find(height2 => height2.id === prop(\"id\"));\n      return height?.height ?? 0;\n    },\n    heightIndex: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      return heights.findIndex(height => height.id === prop(\"id\"));\n    },\n    frontmost: ({\n      prop\n    }) => prop(\"index\") === 0,\n    heightBefore: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const heightIndex = heights.findIndex(height => height.id === prop(\"id\"));\n      return heights.reduce((prev, curr, reducerIndex) => {\n        if (reducerIndex >= heightIndex) return prev;\n        return prev + curr.height;\n      }, 0);\n    },\n    shouldPersist: ({\n      prop\n    }) => prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity\n  },\n  watch({\n    track,\n    prop,\n    send\n  }) {\n    track([() => prop(\"message\")], () => {\n      const message = prop(\"message\");\n      if (message) send({\n        type: message,\n        src: \"programmatic\"\n      });\n    });\n    track([() => prop(\"type\"), () => prop(\"duration\")], () => {\n      send({\n        type: \"UPDATE\"\n      });\n    });\n  },\n  on: {\n    UPDATE: [{\n      guard: \"shouldPersist\",\n      target: \"visible:persist\",\n      actions: [\"resetCloseTimer\"]\n    }, {\n      target: \"visible:updating\",\n      actions: [\"resetCloseTimer\"]\n    }],\n    MEASURE: {\n      actions: [\"measureHeight\"]\n    }\n  },\n  entry: [\"setMounted\", \"measureHeight\", \"invokeOnVisible\"],\n  effects: [\"trackHeight\"],\n  states: {\n    \"visible:updating\": {\n      tags: [\"visible\", \"updating\"],\n      effects: [\"waitForNextTick\"],\n      on: {\n        SHOW: {\n          target: \"visible\"\n        }\n      }\n    },\n    \"visible:persist\": {\n      tags: [\"visible\", \"paused\"],\n      on: {\n        RESUME: {\n          guard: not(\"isLoadingType\"),\n          target: \"visible\",\n          actions: [\"setCloseTimer\"]\n        },\n        DISMISS: {\n          target: \"dismissing\"\n        }\n      }\n    },\n    visible: {\n      tags: [\"visible\"],\n      effects: [\"waitForDuration\"],\n      on: {\n        DISMISS: {\n          target: \"dismissing\"\n        },\n        PAUSE: {\n          target: \"visible:persist\",\n          actions: [\"syncRemainingTime\"]\n        }\n      }\n    },\n    dismissing: {\n      entry: [\"invokeOnDismiss\"],\n      effects: [\"waitForRemoveDelay\"],\n      on: {\n        REMOVE: {\n          target: \"unmounted\",\n          actions: [\"notifyParentToRemove\"]\n        }\n      }\n    },\n    unmounted: {\n      entry: [\"invokeOnUnmount\"]\n    }\n  },\n  implementations: {\n    effects: {\n      waitForRemoveDelay({\n        prop,\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"REMOVE\",\n            src: \"timer\"\n          });\n        }, prop(\"removeDelay\"));\n      },\n      waitForDuration({\n        send,\n        context,\n        computed\n      }) {\n        if (computed(\"shouldPersist\")) return;\n        return setRafTimeout(() => {\n          send({\n            type: \"DISMISS\",\n            src: \"timer\"\n          });\n        }, context.get(\"remainingTime\"));\n      },\n      waitForNextTick({\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"SHOW\",\n            src: \"timer\"\n          });\n        }, 0);\n      },\n      trackHeight({\n        scope,\n        prop\n      }) {\n        let cleanup;\n        raf(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const height = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            const item = {\n              id: prop(\"id\"),\n              height\n            };\n            setHeight(prop(\"parent\"), item);\n          };\n          const win = scope.getWin();\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isLoadingType: ({\n        prop\n      }) => prop(\"type\") === \"loading\",\n      shouldPersist: ({\n        computed\n      }) => computed(\"shouldPersist\")\n    },\n    actions: {\n      setMounted({\n        context\n      }) {\n        raf(() => {\n          context.set(\"mounted\", true);\n        });\n      },\n      measureHeight({\n        scope,\n        prop,\n        context\n      }) {\n        queueMicrotask(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const height = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          context.set(\"initialHeight\", height);\n          const item = {\n            id: prop(\"id\"),\n            height\n          };\n          setHeight(prop(\"parent\"), item);\n        });\n      },\n      setCloseTimer({\n        refs\n      }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n      },\n      resetCloseTimer({\n        context,\n        refs,\n        prop\n      }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n        context.set(\"remainingTime\", getToastDuration(prop(\"duration\"), prop(\"type\")));\n      },\n      syncRemainingTime({\n        context,\n        refs\n      }) {\n        context.set(\"remainingTime\", prev => {\n          const closeTimerStartTime = refs.get(\"closeTimerStartTime\");\n          const elapsedTime = Date.now() - closeTimerStartTime;\n          refs.set(\"lastCloseStartTimerStartTime\", Date.now());\n          return prev - elapsedTime;\n        });\n      },\n      notifyParentToRemove({\n        prop\n      }) {\n        const parent = prop(\"parent\");\n        parent.send({\n          type: \"TOAST.REMOVE\",\n          id: prop(\"id\")\n        });\n      },\n      invokeOnDismiss({\n        prop,\n        event\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"dismissing\",\n          src: event.src\n        });\n      },\n      invokeOnUnmount({\n        prop\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"unmounted\"\n        });\n      },\n      invokeOnVisible({\n        prop\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"visible\"\n        });\n      }\n    }\n  }\n});\nfunction setHeight(parent, item) {\n  const {\n    id,\n    height\n  } = item;\n  parent.context.set(\"heights\", prev => {\n    const alreadyExists = prev.find(i => i.id === id);\n    if (!alreadyExists) {\n      return [{\n        id,\n        height\n      }, ...prev];\n    } else {\n      return prev.map(i => i.id === id ? {\n        ...i,\n        height\n      } : i);\n    }\n  });\n}\nvar withDefaults = (options, defaults) => {\n  return {\n    ...defaults,\n    ...compact(options)\n  };\n};\nfunction createToastStore(props = {}) {\n  const attrs = withDefaults(props, {\n    placement: \"bottom\",\n    overlap: false,\n    max: 24,\n    gap: 16,\n    offsets: \"1rem\",\n    hotkey: [\"altKey\", \"KeyT\"],\n    removeDelay: 200,\n    pauseOnPageIdle: true\n  });\n  let subscribers = [];\n  let toasts = [];\n  let dismissedToasts = /* @__PURE__ */new Set();\n  let toastQueue = [];\n  const subscribe = subscriber => {\n    subscribers.push(subscriber);\n    return () => {\n      const index = subscribers.indexOf(subscriber);\n      subscribers.splice(index, 1);\n    };\n  };\n  const publish = data => {\n    subscribers.forEach(subscriber => subscriber(data));\n    return data;\n  };\n  const addToast = data => {\n    if (toasts.length >= attrs.max) {\n      toastQueue.push(data);\n      return;\n    }\n    publish(data);\n    toasts.unshift(data);\n  };\n  const processQueue = () => {\n    while (toastQueue.length > 0 && toasts.length < attrs.max) {\n      const nextToast = toastQueue.shift();\n      if (nextToast) {\n        publish(nextToast);\n        toasts.unshift(nextToast);\n      }\n    }\n  };\n  const create = data => {\n    const id = data.id ?? `toast:${uuid()}`;\n    const exists = toasts.find(toast => toast.id === id);\n    if (dismissedToasts.has(id)) dismissedToasts.delete(id);\n    if (exists) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) {\n          return publish({\n            ...toast,\n            ...data,\n            id\n          });\n        }\n        return toast;\n      });\n    } else {\n      addToast({\n        id,\n        duration: attrs.duration,\n        removeDelay: attrs.removeDelay,\n        type: \"info\",\n        ...data,\n        stacked: !attrs.overlap,\n        gap: attrs.gap\n      });\n    }\n    return id;\n  };\n  const remove = id => {\n    dismissedToasts.add(id);\n    if (!id) {\n      toasts.forEach(toast => {\n        subscribers.forEach(subscriber => subscriber({\n          id: toast.id,\n          dismiss: true\n        }));\n      });\n      toasts = [];\n      toastQueue = [];\n    } else {\n      subscribers.forEach(subscriber => subscriber({\n        id,\n        dismiss: true\n      }));\n      toasts = toasts.filter(toast => toast.id !== id);\n      processQueue();\n    }\n    return id;\n  };\n  const error = data => {\n    return create({\n      ...data,\n      type: \"error\"\n    });\n  };\n  const success = data => {\n    return create({\n      ...data,\n      type: \"success\"\n    });\n  };\n  const info = data => {\n    return create({\n      ...data,\n      type: \"info\"\n    });\n  };\n  const warning = data => {\n    return create({\n      ...data,\n      type: \"warning\"\n    });\n  };\n  const loading = data => {\n    return create({\n      ...data,\n      type: \"loading\"\n    });\n  };\n  const getVisibleToasts = () => {\n    return toasts.filter(toast => !dismissedToasts.has(toast.id));\n  };\n  const getCount = () => {\n    return toasts.length;\n  };\n  const promise = (promise2, options, shared = {}) => {\n    if (!options || !options.loading) {\n      warn(\"[zag-js > toast] toaster.promise() requires at least a 'loading' option to be specified\");\n      return;\n    }\n    const id = create({\n      ...shared,\n      ...options.loading,\n      promise: promise2,\n      type: \"loading\"\n    });\n    let removable = true;\n    let result;\n    const prom = runIfFn(promise2).then(async response => {\n      result = [\"resolve\", response];\n      if (isHttpResponse(response) && !response.ok) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, `HTTP Error! status: ${response.status}`);\n        create({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      } else if (options.success !== void 0) {\n        removable = false;\n        const successOptions = runIfFn(options.success, response);\n        create({\n          ...shared,\n          ...successOptions,\n          id,\n          type: \"success\"\n        });\n      }\n    }).catch(async error2 => {\n      result = [\"reject\", error2];\n      if (options.error !== void 0) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, error2);\n        create({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      }\n    }).finally(() => {\n      if (removable) {\n        remove(id);\n      }\n      options.finally?.();\n    });\n    const unwrap = () => new Promise((resolve, reject) => prom.then(() => result[0] === \"reject\" ? reject(result[1]) : resolve(result[1])).catch(reject));\n    return {\n      id,\n      unwrap\n    };\n  };\n  const update = (id, data) => {\n    return create({\n      id,\n      ...data\n    });\n  };\n  const pause = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"PAUSE\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"PAUSE\"\n      }));\n    }\n  };\n  const resume = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"RESUME\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"RESUME\"\n      }));\n    }\n  };\n  const dismiss = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"DISMISS\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"DISMISS\"\n      }));\n    }\n  };\n  const isVisible = id => {\n    return !dismissedToasts.has(id) && !!toasts.find(toast => toast.id === id);\n  };\n  const isDismissed = id => {\n    return dismissedToasts.has(id);\n  };\n  const expand = () => {\n    toasts = toasts.map(toast => publish({\n      ...toast,\n      stacked: true\n    }));\n  };\n  const collapse = () => {\n    toasts = toasts.map(toast => publish({\n      ...toast,\n      stacked: false\n    }));\n  };\n  return {\n    attrs,\n    subscribe,\n    create,\n    update,\n    remove,\n    dismiss,\n    error,\n    success,\n    info,\n    warning,\n    loading,\n    getVisibleToasts,\n    getCount,\n    promise,\n    pause,\n    resume,\n    isVisible,\n    isDismissed,\n    expand,\n    collapse\n  };\n}\nvar isHttpResponse = data => {\n  return data && typeof data === \"object\" && \"ok\" in data && typeof data.ok === \"boolean\" && \"status\" in data && typeof data.status === \"number\";\n};\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\nexport { anatomy, connect, createToastStore as createStore, group, machine };","map":{"version":3,"names":["addDomEvent","AnimationFrame","raf","contains","dataAttr","MAX_Z_INDEX","createAnatomy","setup","createGuards","createMachine","createMachine$1","trackDismissableBranch","uuid","setRafTimeout","ensureProps","warn","runIfFn","compact","anatomy","parts","build","getRegionId","placement","getRegionEl","ctx","getById","getRootId","id","getRootEl","getTitleId","getDescriptionId","getCloseTriggerId","defaultTimeouts","info","error","success","loading","Infinity","DEFAULT","getToastDuration","duration","type","getOffsets","offsets","left","right","bottom","top","getGroupPlacementStyle","service","prop","computed","context","gap","attrs","heights","get","computedOffset","rtl","computedPlacement","replace","isRighty","includes","isLefty","styles","position","pointerEvents","display","flexDirection","height","zIndex","alignItems","offset","insetInlineEnd","insetInlineStart","getPlacementStyle","visible","parent","side","split","mounted","remainingTime","frontmost","sibling","overlap","stacked","Number","MAX_SAFE_INTEGER","assign","overrides","Object","getGhostBeforeStyle","inset","scale","getGhostAfterStyle","width","groupConnect","normalize","send","refs","getCount","length","getToasts","getGroupProps","options","label","hotkey","hotkeyLabel","join","align","element","group","dir","tabIndex","role","style","onMouseEnter","isActive","onMouseMove","onMouseLeave","onFocus","event","target","relatedTarget","onBlur","currentTarget","queueMicrotask","subscribe","fn","store","guards","and","groupMachine","props","initialState","lastFocusedEl","isFocusWithin","isPointerWithin","ignoreMouseTimer","create","dismissableCleanup","bindable","toasts","defaultValue","sync","hash","map","t","count","effects","watch","track","action","exit","on","actions","guard","states","stack","implementations","isOverlapping","isPointerOut","subscribeToStore","toast","dismiss","set","prev","filter","index","findIndex","slice","trackHotKeyPress","handleKeyDown","isHotkeyPressed","every","key","code","document","capture","trackDocumentVisibility","scope","pauseOnPageIdle","doc","getDoc","isHidden","visibilityState","setDismissableBranch","hasToasts","groupEl","cleanup","defer","clearDismissableBranch","focusRegionEl","focus","pauseToasts","pause","resumeToasts","resume","expandToasts","expand","collapseToasts","collapse","removeToast","remove","removeHeight","collapsedIfEmpty","setLastFocusedEl","restoreFocusIfPointerOut","preventScroll","setPointerWithin","clearPointerWithin","clearFocusWithin","clearLastFocusedEl","ignoreMouseEventsTemporarily","request","clearMouseEventTimer","cancel","connect","state","hasTag","paused","title","description","closable","src","getRootProps","root","onKeyDown","defaultPrevented","preventDefault","getGhostBeforeProps","getGhostAfterProps","getTitleProps","getDescriptionProps","getActionTriggerProps","button","actionTrigger","onClick","getCloseTriggerProps","closeTrigger","not","machine","persist","createdAt","Date","now","initialHeight","closeTimerStartTime","lastCloseStartTimerStartTime","find","height2","heightIndex","heightBefore","reduce","curr","reducerIndex","shouldPersist","message","UPDATE","MEASURE","entry","tags","SHOW","RESUME","DISMISS","PAUSE","dismissing","REMOVE","unmounted","waitForRemoveDelay","waitForDuration","waitForNextTick","trackHeight","rootEl","syncHeight","originalHeight","getBoundingClientRect","item","setHeight","win","getWin","observer","MutationObserver","observe","childList","subtree","characterData","disconnect","isLoadingType","setMounted","measureHeight","setCloseTimer","resetCloseTimer","syncRemainingTime","elapsedTime","notifyParentToRemove","invokeOnDismiss","status","invokeOnUnmount","invokeOnVisible","alreadyExists","i","withDefaults","defaults","createToastStore","max","removeDelay","subscribers","dismissedToasts","Set","toastQueue","subscriber","push","indexOf","splice","publish","data","forEach","addToast","unshift","processQueue","nextToast","shift","exists","has","delete","add","warning","getVisibleToasts","promise","promise2","shared","removable","result","prom","then","response","isHttpResponse","ok","errorOptions","successOptions","catch","error2","finally","unwrap","Promise","resolve","reject","update","isVisible","isDismissed","createStore"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@zag-js/toast/dist/index.mjs"],"sourcesContent":["import { addDomEvent, AnimationFrame, raf, contains, dataAttr, MAX_Z_INDEX } from '@zag-js/dom-query';\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { setup, createGuards, createMachine as createMachine$1 } from '@zag-js/core';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\nimport { uuid, setRafTimeout, ensureProps, warn, runIfFn, compact } from '@zag-js/utils';\n\n// src/toast-group.connect.ts\nvar anatomy = createAnatomy(\"toast\").parts(\n  \"group\",\n  \"root\",\n  \"title\",\n  \"description\",\n  \"actionTrigger\",\n  \"closeTrigger\"\n);\nvar parts = anatomy.build();\n\n// src/toast.dom.ts\nvar getRegionId = (placement) => `toast-group:${placement}`;\nvar getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);\nvar getRootId = (ctx) => `toast:${ctx.id}`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getTitleId = (ctx) => `toast:${ctx.id}:title`;\nvar getDescriptionId = (ctx) => `toast:${ctx.id}:description`;\nvar getCloseTriggerId = (ctx) => `toast${ctx.id}:close`;\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nvar getOffsets = (offsets) => typeof offsets === \"string\" ? { left: offsets, right: offsets, bottom: offsets, top: offsets } : offsets;\nfunction getGroupPlacementStyle(service, placement) {\n  const { prop, computed, context } = service;\n  const { offsets, gap } = prop(\"store\").attrs;\n  const heights = context.get(\"heights\");\n  const computedOffset = getOffsets(offsets);\n  const rtl = prop(\"dir\") === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: computed(\"count\") > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${gap}px`,\n    \"--first-height\": `${heights[0]?.height || 0}px`,\n    \"--viewport-offset-left\": computedOffset.left,\n    \"--viewport-offset-right\": computedOffset.right,\n    \"--viewport-offset-top\": computedOffset.top,\n    \"--viewport-offset-bottom\": computedOffset.bottom,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(service, visible) {\n  const { prop, context, computed } = service;\n  const parent = prop(\"parent\");\n  const placement = parent.computed(\"placement\");\n  const { gap } = parent.prop(\"store\").attrs;\n  const [side] = placement.split(\"-\");\n  const mounted = context.get(\"mounted\");\n  const remainingTime = context.get(\"remainingTime\");\n  const height = computed(\"height\");\n  const frontmost = computed(\"frontmost\");\n  const sibling = !frontmost;\n  const overlap = !prop(\"stacked\");\n  const stacked = prop(\"stacked\");\n  const type = prop(\"type\");\n  const duration = type === \"loading\" ? Number.MAX_SAFE_INTEGER : remainingTime;\n  const offset = computed(\"heightIndex\") * gap + computed(\"heightBefore\");\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${prop(\"removeDelay\")}ms`,\n    \"--duration\": `${duration}ms`,\n    \"--initial-height\": `${height}px`,\n    \"--offset\": `${offset}px`,\n    \"--index\": prop(\"index\"),\n    \"--z-index\": computed(\"zIndex\"),\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = (overrides) => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(service, visible) {\n  const { computed } = service;\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = (overrides) => Object.assign(styles, overrides);\n  if (computed(\"frontmost\") && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle() {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(service, normalize) {\n  const { context, prop, send, refs, computed } = service;\n  return {\n    getCount() {\n      return context.get(\"toasts\").length;\n    },\n    getToasts() {\n      return context.get(\"toasts\");\n    },\n    getGroupProps(options = {}) {\n      const { label = \"Notifications\" } = options;\n      const { hotkey } = prop(\"store\").attrs;\n      const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const placement = computed(\"placement\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: prop(\"dir\"),\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(service, placement),\n        onMouseEnter() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({ type: \"REGION.POINTER_ENTER\", placement });\n        },\n        onMouseMove() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({ type: \"REGION.POINTER_ENTER\", placement });\n        },\n        onMouseLeave() {\n          if (refs.get(\"ignoreMouseTimer\").isActive()) return;\n          send({ type: \"REGION.POINTER_LEAVE\", placement });\n        },\n        onFocus(event) {\n          send({ type: \"REGION.FOCUS\", target: event.relatedTarget });\n        },\n        onBlur(event) {\n          if (refs.get(\"isFocusWithin\") && !contains(event.currentTarget, event.relatedTarget)) {\n            queueMicrotask(() => send({ type: \"REGION.BLUR\" }));\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const store = prop(\"store\");\n      return store.subscribe(() => fn(context.get(\"toasts\")));\n    }\n  };\n}\nvar { guards, createMachine } = setup();\nvar { and } = guards;\nvar groupMachine = createMachine({\n  props({ props }) {\n    return {\n      dir: \"ltr\",\n      id: uuid(),\n      ...props,\n      store: props.store\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"store\").attrs.overlap ? \"overlap\" : \"stack\";\n  },\n  refs() {\n    return {\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      isPointerWithin: false,\n      ignoreMouseTimer: AnimationFrame.create(),\n      dismissableCleanup: void 0\n    };\n  },\n  context({ bindable }) {\n    return {\n      toasts: bindable(() => ({\n        defaultValue: [],\n        sync: true,\n        hash: (toasts) => toasts.map((t) => t.id).join(\",\")\n      })),\n      heights: bindable(() => ({\n        defaultValue: [],\n        sync: true\n      }))\n    };\n  },\n  computed: {\n    count: ({ context }) => context.get(\"toasts\").length,\n    overlap: ({ prop }) => prop(\"store\").attrs.overlap,\n    placement: ({ prop }) => prop(\"store\").attrs.placement\n  },\n  effects: [\"subscribeToStore\", \"trackDocumentVisibility\", \"trackHotKeyPress\"],\n  watch({ track, context, action }) {\n    track([() => context.hash(\"toasts\")], () => {\n      queueMicrotask(() => {\n        action([\"collapsedIfEmpty\", \"setDismissableBranch\"]);\n      });\n    });\n  },\n  exit: [\"clearDismissableBranch\", \"clearLastFocusedEl\", \"clearMouseEventTimer\"],\n  on: {\n    \"DOC.HOTKEY\": {\n      actions: [\"focusRegionEl\"]\n    },\n    \"REGION.BLUR\": [\n      {\n        guard: and(\"isOverlapping\", \"isPointerOut\"),\n        target: \"overlap\",\n        actions: [\"collapseToasts\", \"resumeToasts\", \"restoreFocusIfPointerOut\"]\n      },\n      {\n        guard: \"isPointerOut\",\n        target: \"stack\",\n        actions: [\"resumeToasts\", \"restoreFocusIfPointerOut\"]\n      },\n      {\n        actions: [\"clearFocusWithin\"]\n      }\n    ],\n    \"TOAST.REMOVE\": {\n      actions: [\"removeToast\", \"removeHeight\", \"ignoreMouseEventsTemporarily\"]\n    },\n    \"TOAST.PAUSE\": {\n      actions: [\"pauseToasts\"]\n    }\n  },\n  states: {\n    stack: {\n      on: {\n        \"REGION.POINTER_LEAVE\": [\n          {\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"clearPointerWithin\", \"resumeToasts\", \"collapseToasts\"]\n          },\n          {\n            actions: [\"clearPointerWithin\", \"resumeToasts\"]\n          }\n        ],\n        \"REGION.OVERLAP\": {\n          target: \"overlap\",\n          actions: [\"collapseToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          actions: [\"setPointerWithin\", \"pauseToasts\"]\n        }\n      }\n    },\n    overlap: {\n      on: {\n        \"REGION.STACK\": {\n          target: \"stack\",\n          actions: [\"expandToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          target: \"stack\",\n          actions: [\"setPointerWithin\", \"pauseToasts\", \"expandToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          target: \"stack\",\n          actions: [\"setLastFocusedEl\", \"pauseToasts\", \"expandToasts\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOverlapping: ({ computed }) => computed(\"overlap\"),\n      isPointerOut: ({ refs }) => !refs.get(\"isPointerWithin\")\n    },\n    effects: {\n      subscribeToStore({ context, prop }) {\n        return prop(\"store\").subscribe((toast) => {\n          if (toast.dismiss) {\n            context.set(\"toasts\", (prev) => prev.filter((t) => t.id !== toast.id));\n            return;\n          }\n          context.set(\"toasts\", (prev) => {\n            const index = prev.findIndex((t) => t.id === toast.id);\n            if (index !== -1) {\n              return [...prev.slice(0, index), { ...prev[index], ...toast }, ...prev.slice(index + 1)];\n            }\n            return [toast, ...prev];\n          });\n        });\n      },\n      trackHotKeyPress({ prop, send }) {\n        const handleKeyDown = (event) => {\n          const { hotkey } = prop(\"store\").attrs;\n          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({ type: \"DOC.HOTKEY\" });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, { capture: true });\n      },\n      trackDocumentVisibility({ prop, send, scope }) {\n        const { pauseOnPageIdle } = prop(\"store\").attrs;\n        if (!pauseOnPageIdle) return;\n        const doc = scope.getDoc();\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          const isHidden = doc.visibilityState === \"hidden\";\n          send({ type: isHidden ? \"PAUSE_ALL\" : \"RESUME_ALL\" });\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch({ refs, context, computed, scope }) {\n        const toasts = context.get(\"toasts\");\n        const placement = computed(\"placement\");\n        const hasToasts = toasts.length > 0;\n        if (!hasToasts) {\n          refs.get(\"dismissableCleanup\")?.();\n          return;\n        }\n        if (hasToasts && refs.get(\"dismissableCleanup\")) {\n          return;\n        }\n        const groupEl = () => getRegionEl(scope, placement);\n        const cleanup = trackDismissableBranch(groupEl, { defer: true });\n        refs.set(\"dismissableCleanup\", cleanup);\n      },\n      clearDismissableBranch({ refs }) {\n        refs.get(\"dismissableCleanup\")?.();\n      },\n      focusRegionEl({ scope, computed }) {\n        queueMicrotask(() => {\n          getRegionEl(scope, computed(\"placement\"))?.focus();\n        });\n      },\n      pauseToasts({ prop }) {\n        prop(\"store\").pause();\n      },\n      resumeToasts({ prop }) {\n        prop(\"store\").resume();\n      },\n      expandToasts({ prop }) {\n        prop(\"store\").expand();\n      },\n      collapseToasts({ prop }) {\n        prop(\"store\").collapse();\n      },\n      removeToast({ prop, event }) {\n        prop(\"store\").remove(event.id);\n      },\n      removeHeight({ event, context }) {\n        if (event?.id == null) return;\n        queueMicrotask(() => {\n          context.set(\"heights\", (heights) => heights.filter((height) => height.id !== event.id));\n        });\n      },\n      collapsedIfEmpty({ send, computed }) {\n        if (!computed(\"overlap\") || computed(\"count\") > 1) return;\n        send({ type: \"REGION.OVERLAP\" });\n      },\n      setLastFocusedEl({ refs, event }) {\n        if (refs.get(\"isFocusWithin\") || !event.target) return;\n        refs.set(\"isFocusWithin\", true);\n        refs.set(\"lastFocusedEl\", event.target);\n      },\n      restoreFocusIfPointerOut({ refs }) {\n        if (!refs.get(\"lastFocusedEl\") || refs.get(\"isPointerWithin\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({ preventScroll: true });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      },\n      setPointerWithin({ refs }) {\n        refs.set(\"isPointerWithin\", true);\n      },\n      clearPointerWithin({ refs }) {\n        refs.set(\"isPointerWithin\", false);\n        if (refs.get(\"lastFocusedEl\") && !refs.get(\"isFocusWithin\")) {\n          refs.get(\"lastFocusedEl\")?.focus({ preventScroll: true });\n          refs.set(\"lastFocusedEl\", null);\n        }\n      },\n      clearFocusWithin({ refs }) {\n        refs.set(\"isFocusWithin\", false);\n      },\n      clearLastFocusedEl({ refs }) {\n        if (!refs.get(\"lastFocusedEl\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({ preventScroll: true });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      },\n      ignoreMouseEventsTemporarily({ refs }) {\n        refs.get(\"ignoreMouseTimer\").request();\n      },\n      clearMouseEventTimer({ refs }) {\n        refs.get(\"ignoreMouseTimer\").cancel();\n      }\n    }\n  }\n});\nfunction connect(service, normalize) {\n  const { state, send, prop, scope, context, computed } = service;\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const mounted = context.get(\"mounted\");\n  const frontmost = computed(\"frontmost\");\n  const placement = prop(\"parent\").computed(\"placement\");\n  const type = prop(\"type\");\n  const stacked = prop(\"stacked\");\n  const title = prop(\"title\");\n  const description = prop(\"description\");\n  const action = prop(\"action\");\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title,\n    description,\n    placement,\n    visible,\n    paused,\n    closable: !!prop(\"closable\"),\n    pause() {\n      send({ type: \"PAUSE\" });\n    },\n    resume() {\n      send({ type: \"RESUME\" });\n    },\n    dismiss() {\n      send({ type: \"DISMISS\", src: \"programmatic\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(frontmost),\n        \"data-sibling\": dataAttr(!frontmost),\n        \"data-stack\": dataAttr(stacked),\n        \"data-overlap\": dataAttr(!stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": description ? getDescriptionId(scope) : void 0,\n        \"aria-labelledby\": title ? getTitleId(scope) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(service, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send({ type: \"DISMISS\", src: \"keyboard\" });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(service, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle()\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: getDescriptionId(scope)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          action?.onClick?.();\n          send({ type: \"DISMISS\", src: \"user\" });\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: getCloseTriggerId(scope),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: \"DISMISS\", src: \"user\" });\n        }\n      });\n    }\n  };\n}\nvar { not } = createGuards();\nvar machine = createMachine$1({\n  props({ props }) {\n    ensureProps(props, [\"id\", \"type\", \"parent\", \"removeDelay\"], \"toast\");\n    return {\n      closable: true,\n      ...props,\n      duration: getToastDuration(props.duration, props.type)\n    };\n  },\n  initialState({ prop }) {\n    const persist = prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity;\n    return persist ? \"visible:persist\" : \"visible\";\n  },\n  context({ prop, bindable }) {\n    return {\n      remainingTime: bindable(() => ({\n        defaultValue: getToastDuration(prop(\"duration\"), prop(\"type\"))\n      })),\n      createdAt: bindable(() => ({\n        defaultValue: Date.now()\n      })),\n      mounted: bindable(() => ({\n        defaultValue: false\n      })),\n      initialHeight: bindable(() => ({\n        defaultValue: 0\n      }))\n    };\n  },\n  refs() {\n    return {\n      closeTimerStartTime: Date.now(),\n      lastCloseStartTimerStartTime: 0\n    };\n  },\n  computed: {\n    zIndex: ({ prop }) => {\n      const toasts = prop(\"parent\").context.get(\"toasts\");\n      const index = toasts.findIndex((toast) => toast.id === prop(\"id\"));\n      return toasts.length - index;\n    },\n    height: ({ prop }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const height = heights.find((height2) => height2.id === prop(\"id\"));\n      return height?.height ?? 0;\n    },\n    heightIndex: ({ prop }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      return heights.findIndex((height) => height.id === prop(\"id\"));\n    },\n    frontmost: ({ prop }) => prop(\"index\") === 0,\n    heightBefore: ({ prop }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const heightIndex = heights.findIndex((height) => height.id === prop(\"id\"));\n      return heights.reduce((prev, curr, reducerIndex) => {\n        if (reducerIndex >= heightIndex) return prev;\n        return prev + curr.height;\n      }, 0);\n    },\n    shouldPersist: ({ prop }) => prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity\n  },\n  watch({ track, prop, send }) {\n    track([() => prop(\"message\")], () => {\n      const message = prop(\"message\");\n      if (message) send({ type: message, src: \"programmatic\" });\n    });\n    track([() => prop(\"type\"), () => prop(\"duration\")], () => {\n      send({ type: \"UPDATE\" });\n    });\n  },\n  on: {\n    UPDATE: [\n      {\n        guard: \"shouldPersist\",\n        target: \"visible:persist\",\n        actions: [\"resetCloseTimer\"]\n      },\n      {\n        target: \"visible:updating\",\n        actions: [\"resetCloseTimer\"]\n      }\n    ],\n    MEASURE: {\n      actions: [\"measureHeight\"]\n    }\n  },\n  entry: [\"setMounted\", \"measureHeight\", \"invokeOnVisible\"],\n  effects: [\"trackHeight\"],\n  states: {\n    \"visible:updating\": {\n      tags: [\"visible\", \"updating\"],\n      effects: [\"waitForNextTick\"],\n      on: {\n        SHOW: {\n          target: \"visible\"\n        }\n      }\n    },\n    \"visible:persist\": {\n      tags: [\"visible\", \"paused\"],\n      on: {\n        RESUME: {\n          guard: not(\"isLoadingType\"),\n          target: \"visible\",\n          actions: [\"setCloseTimer\"]\n        },\n        DISMISS: {\n          target: \"dismissing\"\n        }\n      }\n    },\n    visible: {\n      tags: [\"visible\"],\n      effects: [\"waitForDuration\"],\n      on: {\n        DISMISS: {\n          target: \"dismissing\"\n        },\n        PAUSE: {\n          target: \"visible:persist\",\n          actions: [\"syncRemainingTime\"]\n        }\n      }\n    },\n    dismissing: {\n      entry: [\"invokeOnDismiss\"],\n      effects: [\"waitForRemoveDelay\"],\n      on: {\n        REMOVE: {\n          target: \"unmounted\",\n          actions: [\"notifyParentToRemove\"]\n        }\n      }\n    },\n    unmounted: {\n      entry: [\"invokeOnUnmount\"]\n    }\n  },\n  implementations: {\n    effects: {\n      waitForRemoveDelay({ prop, send }) {\n        return setRafTimeout(() => {\n          send({ type: \"REMOVE\", src: \"timer\" });\n        }, prop(\"removeDelay\"));\n      },\n      waitForDuration({ send, context, computed }) {\n        if (computed(\"shouldPersist\")) return;\n        return setRafTimeout(() => {\n          send({ type: \"DISMISS\", src: \"timer\" });\n        }, context.get(\"remainingTime\"));\n      },\n      waitForNextTick({ send }) {\n        return setRafTimeout(() => {\n          send({ type: \"SHOW\", src: \"timer\" });\n        }, 0);\n      },\n      trackHeight({ scope, prop }) {\n        let cleanup;\n        raf(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const height = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            const item = { id: prop(\"id\"), height };\n            setHeight(prop(\"parent\"), item);\n          };\n          const win = scope.getWin();\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isLoadingType: ({ prop }) => prop(\"type\") === \"loading\",\n      shouldPersist: ({ computed }) => computed(\"shouldPersist\")\n    },\n    actions: {\n      setMounted({ context }) {\n        raf(() => {\n          context.set(\"mounted\", true);\n        });\n      },\n      measureHeight({ scope, prop, context }) {\n        queueMicrotask(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const height = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          context.set(\"initialHeight\", height);\n          const item = { id: prop(\"id\"), height };\n          setHeight(prop(\"parent\"), item);\n        });\n      },\n      setCloseTimer({ refs }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n      },\n      resetCloseTimer({ context, refs, prop }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n        context.set(\"remainingTime\", getToastDuration(prop(\"duration\"), prop(\"type\")));\n      },\n      syncRemainingTime({ context, refs }) {\n        context.set(\"remainingTime\", (prev) => {\n          const closeTimerStartTime = refs.get(\"closeTimerStartTime\");\n          const elapsedTime = Date.now() - closeTimerStartTime;\n          refs.set(\"lastCloseStartTimerStartTime\", Date.now());\n          return prev - elapsedTime;\n        });\n      },\n      notifyParentToRemove({ prop }) {\n        const parent = prop(\"parent\");\n        parent.send({ type: \"TOAST.REMOVE\", id: prop(\"id\") });\n      },\n      invokeOnDismiss({ prop, event }) {\n        prop(\"onStatusChange\")?.({ status: \"dismissing\", src: event.src });\n      },\n      invokeOnUnmount({ prop }) {\n        prop(\"onStatusChange\")?.({ status: \"unmounted\" });\n      },\n      invokeOnVisible({ prop }) {\n        prop(\"onStatusChange\")?.({ status: \"visible\" });\n      }\n    }\n  }\n});\nfunction setHeight(parent, item) {\n  const { id, height } = item;\n  parent.context.set(\"heights\", (prev) => {\n    const alreadyExists = prev.find((i) => i.id === id);\n    if (!alreadyExists) {\n      return [{ id, height }, ...prev];\n    } else {\n      return prev.map((i) => i.id === id ? { ...i, height } : i);\n    }\n  });\n}\nvar withDefaults = (options, defaults) => {\n  return { ...defaults, ...compact(options) };\n};\nfunction createToastStore(props = {}) {\n  const attrs = withDefaults(props, {\n    placement: \"bottom\",\n    overlap: false,\n    max: 24,\n    gap: 16,\n    offsets: \"1rem\",\n    hotkey: [\"altKey\", \"KeyT\"],\n    removeDelay: 200,\n    pauseOnPageIdle: true\n  });\n  let subscribers = [];\n  let toasts = [];\n  let dismissedToasts = /* @__PURE__ */ new Set();\n  let toastQueue = [];\n  const subscribe = (subscriber) => {\n    subscribers.push(subscriber);\n    return () => {\n      const index = subscribers.indexOf(subscriber);\n      subscribers.splice(index, 1);\n    };\n  };\n  const publish = (data) => {\n    subscribers.forEach((subscriber) => subscriber(data));\n    return data;\n  };\n  const addToast = (data) => {\n    if (toasts.length >= attrs.max) {\n      toastQueue.push(data);\n      return;\n    }\n    publish(data);\n    toasts.unshift(data);\n  };\n  const processQueue = () => {\n    while (toastQueue.length > 0 && toasts.length < attrs.max) {\n      const nextToast = toastQueue.shift();\n      if (nextToast) {\n        publish(nextToast);\n        toasts.unshift(nextToast);\n      }\n    }\n  };\n  const create = (data) => {\n    const id = data.id ?? `toast:${uuid()}`;\n    const exists = toasts.find((toast) => toast.id === id);\n    if (dismissedToasts.has(id)) dismissedToasts.delete(id);\n    if (exists) {\n      toasts = toasts.map((toast) => {\n        if (toast.id === id) {\n          return publish({ ...toast, ...data, id });\n        }\n        return toast;\n      });\n    } else {\n      addToast({\n        id,\n        duration: attrs.duration,\n        removeDelay: attrs.removeDelay,\n        type: \"info\",\n        ...data,\n        stacked: !attrs.overlap,\n        gap: attrs.gap\n      });\n    }\n    return id;\n  };\n  const remove = (id) => {\n    dismissedToasts.add(id);\n    if (!id) {\n      toasts.forEach((toast) => {\n        subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));\n      });\n      toasts = [];\n      toastQueue = [];\n    } else {\n      subscribers.forEach((subscriber) => subscriber({ id, dismiss: true }));\n      toasts = toasts.filter((toast) => toast.id !== id);\n      processQueue();\n    }\n    return id;\n  };\n  const error = (data) => {\n    return create({ ...data, type: \"error\" });\n  };\n  const success = (data) => {\n    return create({ ...data, type: \"success\" });\n  };\n  const info = (data) => {\n    return create({ ...data, type: \"info\" });\n  };\n  const warning = (data) => {\n    return create({ ...data, type: \"warning\" });\n  };\n  const loading = (data) => {\n    return create({ ...data, type: \"loading\" });\n  };\n  const getVisibleToasts = () => {\n    return toasts.filter((toast) => !dismissedToasts.has(toast.id));\n  };\n  const getCount = () => {\n    return toasts.length;\n  };\n  const promise = (promise2, options, shared = {}) => {\n    if (!options || !options.loading) {\n      warn(\"[zag-js > toast] toaster.promise() requires at least a 'loading' option to be specified\");\n      return;\n    }\n    const id = create({\n      ...shared,\n      ...options.loading,\n      promise: promise2,\n      type: \"loading\"\n    });\n    let removable = true;\n    let result;\n    const prom = runIfFn(promise2).then(async (response) => {\n      result = [\"resolve\", response];\n      if (isHttpResponse(response) && !response.ok) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, `HTTP Error! status: ${response.status}`);\n        create({ ...shared, ...errorOptions, id, type: \"error\" });\n      } else if (options.success !== void 0) {\n        removable = false;\n        const successOptions = runIfFn(options.success, response);\n        create({ ...shared, ...successOptions, id, type: \"success\" });\n      }\n    }).catch(async (error2) => {\n      result = [\"reject\", error2];\n      if (options.error !== void 0) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, error2);\n        create({ ...shared, ...errorOptions, id, type: \"error\" });\n      }\n    }).finally(() => {\n      if (removable) {\n        remove(id);\n      }\n      options.finally?.();\n    });\n    const unwrap = () => new Promise(\n      (resolve, reject) => prom.then(() => result[0] === \"reject\" ? reject(result[1]) : resolve(result[1])).catch(reject)\n    );\n    return { id, unwrap };\n  };\n  const update = (id, data) => {\n    return create({ id, ...data });\n  };\n  const pause = (id) => {\n    if (id != null) {\n      toasts = toasts.map((toast) => {\n        if (toast.id === id) return publish({ ...toast, message: \"PAUSE\" });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map((toast) => publish({ ...toast, message: \"PAUSE\" }));\n    }\n  };\n  const resume = (id) => {\n    if (id != null) {\n      toasts = toasts.map((toast) => {\n        if (toast.id === id) return publish({ ...toast, message: \"RESUME\" });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map((toast) => publish({ ...toast, message: \"RESUME\" }));\n    }\n  };\n  const dismiss = (id) => {\n    if (id != null) {\n      toasts = toasts.map((toast) => {\n        if (toast.id === id) return publish({ ...toast, message: \"DISMISS\" });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map((toast) => publish({ ...toast, message: \"DISMISS\" }));\n    }\n  };\n  const isVisible = (id) => {\n    return !dismissedToasts.has(id) && !!toasts.find((toast) => toast.id === id);\n  };\n  const isDismissed = (id) => {\n    return dismissedToasts.has(id);\n  };\n  const expand = () => {\n    toasts = toasts.map((toast) => publish({ ...toast, stacked: true }));\n  };\n  const collapse = () => {\n    toasts = toasts.map((toast) => publish({ ...toast, stacked: false }));\n  };\n  return {\n    attrs,\n    subscribe,\n    create,\n    update,\n    remove,\n    dismiss,\n    error,\n    success,\n    info,\n    warning,\n    loading,\n    getVisibleToasts,\n    getCount,\n    promise,\n    pause,\n    resume,\n    isVisible,\n    isDismissed,\n    expand,\n    collapse\n  };\n}\nvar isHttpResponse = (data) => {\n  return data && typeof data === \"object\" && \"ok\" in data && typeof data.ok === \"boolean\" && \"status\" in data && typeof data.status === \"number\";\n};\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\n\nexport { anatomy, connect, createToastStore as createStore, group, machine };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}