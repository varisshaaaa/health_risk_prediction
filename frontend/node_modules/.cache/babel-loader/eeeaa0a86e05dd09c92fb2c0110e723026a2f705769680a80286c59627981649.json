{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, resizeObserverBorderBox, getEventPoint, getEventTarget, dataAttr, getEventKey, contains } from '@zag-js/dom-query';\nimport { callAll, clampValue, createSplitProps, isBoolean, toPx } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/image-cropper.anatomy.ts\nvar anatomy = createAnatomy(\"image-cropper\").parts(\"root\", \"viewport\", \"image\", \"selection\", \"handle\", \"grid\");\nvar parts = anatomy.build();\n\n// src/get-resize-axis-style.ts\nfunction getHandlePositionStyles(handlePosition) {\n  switch (handlePosition) {\n    case \"n\":\n      return {\n        position: \"absolute\",\n        cursor: \"n-resize\",\n        width: \"96%\",\n        top: 0,\n        left: \"50%\",\n        translate: \"-50% -50%\"\n      };\n    case \"e\":\n      return {\n        position: \"absolute\",\n        cursor: \"e-resize\",\n        height: \"96%\",\n        right: 0,\n        top: \"50%\",\n        translate: \"50% -50%\"\n      };\n    case \"s\":\n      return {\n        position: \"absolute\",\n        cursor: \"s-resize\",\n        width: \"96%\",\n        bottom: 0,\n        left: \"50%\",\n        translate: \"-50% 50%\"\n      };\n    case \"w\":\n      return {\n        position: \"absolute\",\n        cursor: \"w-resize\",\n        height: \"96%\",\n        left: 0,\n        top: \"50%\",\n        translate: \"-50% -50%\"\n      };\n    case \"se\":\n      return {\n        position: \"absolute\",\n        cursor: \"se-resize\",\n        bottom: 0,\n        right: 0,\n        translate: \"50% 50%\"\n      };\n    case \"sw\":\n      return {\n        position: \"absolute\",\n        cursor: \"sw-resize\",\n        bottom: 0,\n        left: 0,\n        translate: \"-50% 50%\"\n      };\n    case \"ne\":\n      return {\n        position: \"absolute\",\n        cursor: \"ne-resize\",\n        top: 0,\n        right: 0,\n        translate: \"50% -50%\"\n      };\n    case \"nw\":\n      return {\n        position: \"absolute\",\n        cursor: \"nw-resize\",\n        top: 0,\n        left: 0,\n        translate: \"-50% -50%\"\n      };\n    default:\n      throw new Error(`Invalid handlePosition: ${handlePosition}`);\n  }\n}\n\n// src/image-cropper.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `image-cropper:${ctx.id}`;\nvar getViewportId = ctx => ctx.ids?.viewport ?? `image-cropper:${ctx.id}:viewport`;\nvar getImageId = ctx => ctx.ids?.image ?? `image-cropper:${ctx.id}:image`;\nvar getSelectionId = ctx => ctx.ids?.selection ?? `image-cropper:${ctx.id}:selection`;\nvar getHandleId = (ctx, position) => ctx.ids?.handle?.(position) ?? `image-cropper:${ctx.id}:handle:${position}`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getViewportEl = ctx => ctx.getById(getViewportId(ctx));\nvar getImageEl = ctx => ctx.getById(getImageId(ctx));\nvar getSelectionEl = ctx => ctx.getById(getSelectionId(ctx));\nfunction drawCroppedImageToCanvas(params) {\n  const {\n    context,\n    scope\n  } = params;\n  const imageEl = getImageEl(scope);\n  if (!imageEl || !imageEl.complete) return null;\n  const doc = imageEl.ownerDocument;\n  const crop = context.get(\"crop\");\n  const zoom = context.get(\"zoom\");\n  const rotation = context.get(\"rotation\");\n  const flip = context.get(\"flip\");\n  const viewportRect = context.get(\"viewportRect\");\n  const naturalSize = context.get(\"naturalSize\");\n  const offset = context.get(\"offset\");\n  const canvas = doc.createElement(\"canvas\");\n  canvas.width = crop.width;\n  canvas.height = crop.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return null;\n  ctx.save();\n  ctx.translate(canvas.width / 2, canvas.height / 2);\n  ctx.rotate(rotation * Math.PI / 180);\n  const scaleX = flip.horizontal ? -1 : 1;\n  const scaleY = flip.vertical ? -1 : 1;\n  ctx.scale(scaleX, scaleY);\n  const viewportCenterX = viewportRect.width / 2;\n  const viewportCenterY = viewportRect.height / 2;\n  const cropCenterX = crop.x + crop.width / 2;\n  const cropCenterY = crop.y + crop.height / 2;\n  const deltaX = cropCenterX - viewportCenterX;\n  const deltaY = cropCenterY - viewportCenterY;\n  const imageCenterX = naturalSize.width / 2;\n  const imageCenterY = naturalSize.height / 2;\n  const sourceX = imageCenterX + (deltaX - offset.x) / zoom;\n  const sourceY = imageCenterY + (deltaY - offset.y) / zoom;\n  const sourceWidth = crop.width / zoom;\n  const sourceHeight = crop.height / zoom;\n  ctx.drawImage(imageEl, sourceX - sourceWidth / 2, sourceY - sourceHeight / 2, sourceWidth, sourceHeight, -canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n  ctx.restore();\n  return canvas;\n}\nvar {\n  min,\n  max,\n  abs,\n  round,\n  hypot,\n  PI,\n  cos,\n  sin\n} = Math;\nvar isLeftHandle = handlePosition => handlePosition === \"w\" || handlePosition === \"nw\" || handlePosition === \"sw\";\nvar isRightHandle = handlePosition => handlePosition === \"e\" || handlePosition === \"ne\" || handlePosition === \"se\";\nvar isTopHandle = handlePosition => handlePosition === \"n\" || handlePosition === \"nw\" || handlePosition === \"ne\";\nvar isBottomHandle = handlePosition => handlePosition === \"s\" || handlePosition === \"sw\" || handlePosition === \"se\";\nvar isCornerHandle = handlePosition => (isLeftHandle(handlePosition) || isRightHandle(handlePosition)) && (isTopHandle(handlePosition) || isBottomHandle(handlePosition));\nvar isHorizontalEdgeHandle = handlePosition => (isLeftHandle(handlePosition) || isRightHandle(handlePosition)) && !(isTopHandle(handlePosition) || isBottomHandle(handlePosition));\nvar isVerticalEdgeHandle = handlePosition => (isTopHandle(handlePosition) || isBottomHandle(handlePosition)) && !(isLeftHandle(handlePosition) || isRightHandle(handlePosition));\nvar hasAspectRatio = value => typeof value === \"number\" && value > 0;\nvar resolveSizeLimits = options => {\n  const {\n    minSize,\n    maxSize,\n    viewportSize,\n    aspectRatio\n  } = options;\n  let minWidth = min(minSize.width, viewportSize.width);\n  let minHeight = min(minSize.height, viewportSize.height);\n  let maxWidth = maxSize?.width ?? viewportSize.width;\n  if (!Number.isFinite(maxWidth)) maxWidth = viewportSize.width;\n  maxWidth = min(maxWidth, viewportSize.width);\n  let maxHeight = maxSize?.height ?? viewportSize.height;\n  if (!Number.isFinite(maxHeight)) maxHeight = viewportSize.height;\n  maxHeight = min(maxHeight, viewportSize.height);\n  maxWidth = max(minWidth, maxWidth);\n  maxHeight = max(minHeight, maxHeight);\n  const hasAspect = hasAspectRatio(aspectRatio);\n  if (hasAspect) {\n    const minWidthWithAspect = max(minWidth, minHeight * aspectRatio);\n    const minHeightWithAspect = minWidthWithAspect / aspectRatio;\n    minWidth = min(minWidthWithAspect, viewportSize.width);\n    minHeight = min(minHeightWithAspect, viewportSize.height);\n    let constrainedMaxWidth = min(maxWidth, maxHeight * aspectRatio, viewportSize.width);\n    let constrainedMaxHeight = constrainedMaxWidth / aspectRatio;\n    if (constrainedMaxHeight > maxHeight || constrainedMaxHeight > viewportSize.height) {\n      constrainedMaxHeight = min(maxHeight, viewportSize.height);\n      constrainedMaxWidth = constrainedMaxHeight * aspectRatio;\n    }\n    maxWidth = max(minWidth, min(constrainedMaxWidth, viewportSize.width));\n    maxHeight = max(minHeight, min(constrainedMaxHeight, viewportSize.height));\n  } else {\n    maxWidth = max(minWidth, min(maxWidth, viewportSize.width));\n    maxHeight = max(minHeight, min(maxHeight, viewportSize.height));\n  }\n  return {\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight,\n    hasAspect\n  };\n};\nvar clampAspectSize = params => {\n  const {\n    widthValue,\n    heightValue,\n    limits,\n    viewportRect,\n    aspectRatio\n  } = params;\n  const {\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight\n  } = limits;\n  const constrainWidthFromHeight = height => {\n    let width = clampValue(height * aspectRatio, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    return {\n      width,\n      height: width / aspectRatio\n    };\n  };\n  const clampByWidth = value => {\n    let width = clampValue(value, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    let height = width / aspectRatio;\n    if (height < minHeight) {\n      const constrained = constrainWidthFromHeight(minHeight);\n      width = constrained.width;\n      height = constrained.height;\n    }\n    if (height > maxHeight) {\n      const clampedHeight = min(maxHeight, viewportRect.height);\n      const constrained = constrainWidthFromHeight(clampedHeight);\n      width = constrained.width;\n      height = constrained.height;\n    }\n    if (height > viewportRect.height) {\n      const constrained = constrainWidthFromHeight(viewportRect.height);\n      width = constrained.width;\n      height = constrained.height;\n      if (height < minHeight) {\n        const reconstrainted = constrainWidthFromHeight(minHeight);\n        width = reconstrainted.width;\n        height = reconstrainted.height;\n      }\n    }\n    return {\n      width,\n      height\n    };\n  };\n  const clampByHeight = value => {\n    let height = clampValue(value, minHeight, maxHeight);\n    height = min(height, viewportRect.height);\n    let width = height * aspectRatio;\n    width = clampValue(width, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    let adjustedHeight = width / aspectRatio;\n    if (adjustedHeight < minHeight) {\n      const constrained = constrainWidthFromHeight(minHeight);\n      width = constrained.width;\n      adjustedHeight = constrained.height;\n    }\n    if (adjustedHeight > maxHeight) {\n      const clampedHeight = min(maxHeight, viewportRect.height);\n      const constrained = constrainWidthFromHeight(clampedHeight);\n      width = constrained.width;\n      adjustedHeight = constrained.height;\n    }\n    if (width > viewportRect.width) {\n      width = viewportRect.width;\n      adjustedHeight = width / aspectRatio;\n      if (adjustedHeight > maxHeight) {\n        const clampedHeight = min(maxHeight, viewportRect.height);\n        const constrained = constrainWidthFromHeight(clampedHeight);\n        width = constrained.width;\n        adjustedHeight = constrained.height;\n      }\n      if (adjustedHeight < minHeight) {\n        const constrained = constrainWidthFromHeight(minHeight);\n        width = constrained.width;\n        adjustedHeight = constrained.height;\n      }\n    }\n    return {\n      width,\n      height: adjustedHeight\n    };\n  };\n  const byWidth = clampByWidth(widthValue);\n  const byHeight = clampByHeight(heightValue);\n  const deltaWidth = abs(byWidth.width - widthValue) + abs(byWidth.height - heightValue);\n  const deltaHeight = abs(byHeight.width - widthValue) + abs(byHeight.height - heightValue);\n  return deltaHeight < deltaWidth ? byHeight : byWidth;\n};\nvar applyDeltaToEdges = params => {\n  const {\n    bounds,\n    delta,\n    handlePosition,\n    viewportRect,\n    minSize,\n    maxSize\n  } = params;\n  let {\n    left,\n    top,\n    right,\n    bottom\n  } = bounds;\n  if (isLeftHandle(handlePosition)) {\n    const minLeft = max(0, right - maxSize.width);\n    const maxLeft = right - minSize.width;\n    left = clampValue(left + delta.x, minLeft, maxLeft);\n  }\n  if (isRightHandle(handlePosition)) {\n    const minRight = left + minSize.width;\n    const maxRight = min(viewportRect.width, left + maxSize.width);\n    right = clampValue(right + delta.x, minRight, maxRight);\n  }\n  if (isTopHandle(handlePosition)) {\n    const minTop = max(0, bottom - maxSize.height);\n    const maxTop = bottom - minSize.height;\n    top = clampValue(top + delta.y, minTop, maxTop);\n  }\n  if (isBottomHandle(handlePosition)) {\n    const minBottom = top + minSize.height;\n    const maxBottom = min(viewportRect.height, top + maxSize.height);\n    bottom = clampValue(bottom + delta.y, minBottom, maxBottom);\n  }\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n};\nvar applyAspectToHorizontalResize = params => {\n  const {\n    bounds,\n    limits,\n    viewportRect,\n    aspectRatio,\n    handlePosition\n  } = params;\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = bounds;\n  const centerY = (top + bottom) / 2;\n  let nextWidth = right - left;\n  let nextHeight = nextWidth / aspectRatio;\n  const constrained = clampAspectSize({\n    widthValue: nextWidth,\n    heightValue: nextHeight,\n    limits,\n    viewportRect,\n    aspectRatio\n  });\n  nextWidth = constrained.width;\n  nextHeight = constrained.height;\n  const halfH = nextHeight / 2;\n  let newTop = centerY - halfH;\n  let newBottom = centerY + halfH;\n  if (newTop < 0) {\n    newTop = 0;\n    newBottom = nextHeight;\n  }\n  if (newBottom > viewportRect.height) {\n    newBottom = viewportRect.height;\n    newTop = newBottom - nextHeight;\n  }\n  return {\n    left: isRightHandle(handlePosition) ? left : right - nextWidth,\n    top: newTop,\n    right: isRightHandle(handlePosition) ? left + nextWidth : right,\n    bottom: newBottom\n  };\n};\nvar applyAspectToVerticalResize = params => {\n  const {\n    bounds,\n    limits,\n    viewportRect,\n    aspectRatio,\n    handlePosition\n  } = params;\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = bounds;\n  const centerX = (left + right) / 2;\n  let nextHeight = bottom - top;\n  let nextWidth = nextHeight * aspectRatio;\n  const constrained = clampAspectSize({\n    widthValue: nextWidth,\n    heightValue: nextHeight,\n    limits,\n    viewportRect,\n    aspectRatio\n  });\n  nextWidth = constrained.width;\n  nextHeight = constrained.height;\n  const halfW = nextWidth / 2;\n  let newLeft = centerX - halfW;\n  let newRight = centerX + halfW;\n  if (newLeft < 0) {\n    newLeft = 0;\n    newRight = nextWidth;\n  }\n  if (newRight > viewportRect.width) {\n    newRight = viewportRect.width;\n    newLeft = newRight - nextWidth;\n  }\n  return {\n    left: newLeft,\n    top: isBottomHandle(handlePosition) ? top : bottom - nextHeight,\n    right: newRight,\n    bottom: isBottomHandle(handlePosition) ? top + nextHeight : bottom\n  };\n};\nvar applyCornerResize = params => {\n  const {\n    bounds,\n    width,\n    height,\n    handlePosition\n  } = params;\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = bounds;\n  if (isRightHandle(handlePosition) && isBottomHandle(handlePosition)) {\n    return {\n      left,\n      top,\n      right: left + width,\n      bottom: top + height\n    };\n  } else if (isRightHandle(handlePosition) && isTopHandle(handlePosition)) {\n    return {\n      left,\n      top: bottom - height,\n      right: left + width,\n      bottom\n    };\n  } else if (isBottomHandle(handlePosition)) {\n    return {\n      left: right - width,\n      top,\n      right,\n      bottom: top + height\n    };\n  } else {\n    return {\n      left: right - width,\n      top: bottom - height,\n      right,\n      bottom\n    };\n  }\n};\nfunction computeResizeCrop(options) {\n  const {\n    cropStart,\n    handlePosition,\n    delta,\n    viewportRect,\n    minSize,\n    maxSize,\n    aspectRatio\n  } = options;\n  let {\n    x,\n    y,\n    width,\n    height\n  } = cropStart;\n  let left = x;\n  let top = y;\n  let right = x + width;\n  let bottom = y + height;\n  const {\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight,\n    hasAspect\n  } = resolveSizeLimits({\n    minSize,\n    maxSize,\n    viewportSize: viewportRect,\n    aspectRatio\n  });\n  const edgesAfterDelta = applyDeltaToEdges({\n    bounds: {\n      left,\n      top,\n      right,\n      bottom\n    },\n    delta,\n    handlePosition,\n    viewportRect,\n    minSize,\n    maxSize\n  });\n  left = edgesAfterDelta.left;\n  top = edgesAfterDelta.top;\n  right = edgesAfterDelta.right;\n  bottom = edgesAfterDelta.bottom;\n  if (hasAspect) {\n    const limits = {\n      minWidth,\n      minHeight,\n      maxWidth,\n      maxHeight,\n      hasAspect\n    };\n    if (isCornerHandle(handlePosition)) {\n      let tempW = right - left;\n      let tempH = tempW / aspectRatio;\n      if (tempH > bottom - top || top + tempH > viewportRect.height || left + tempW > viewportRect.width) {\n        tempH = bottom - top;\n        tempW = tempH * aspectRatio;\n      }\n      const constrained = clampAspectSize({\n        widthValue: tempW,\n        heightValue: tempH,\n        limits,\n        viewportRect,\n        aspectRatio\n      });\n      const result = applyCornerResize({\n        bounds: {\n          left,\n          top,\n          right,\n          bottom\n        },\n        width: constrained.width,\n        height: constrained.height,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    } else if (isHorizontalEdgeHandle(handlePosition)) {\n      const result = applyAspectToHorizontalResize({\n        bounds: {\n          left,\n          top,\n          right,\n          bottom\n        },\n        limits,\n        viewportRect,\n        aspectRatio,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    } else if (isVerticalEdgeHandle(handlePosition)) {\n      const result = applyAspectToVerticalResize({\n        bounds: {\n          left,\n          top,\n          right,\n          bottom\n        },\n        limits,\n        viewportRect,\n        aspectRatio,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    }\n  }\n  const maxLeft = max(0, viewportRect.width - minWidth);\n  const maxTop = max(0, viewportRect.height - minHeight);\n  left = clampValue(left, 0, maxLeft);\n  top = clampValue(top, 0, maxTop);\n  const maxRight = min(viewportRect.width, left + maxWidth);\n  const maxBottom = min(viewportRect.height, top + maxHeight);\n  right = clampValue(right, left + minWidth, maxRight);\n  bottom = clampValue(bottom, top + minHeight, maxBottom);\n  return {\n    x: left,\n    y: top,\n    width: right - left,\n    height: bottom - top\n  };\n}\nfunction computeMoveCrop(cropStart, delta, viewportRect) {\n  return {\n    x: clampValue(cropStart.x + delta.x, 0, viewportRect.width - cropStart.width),\n    y: clampValue(cropStart.y + delta.y, 0, viewportRect.height - cropStart.height),\n    width: cropStart.width,\n    height: cropStart.height\n  };\n}\nfunction clampOffset(params) {\n  const {\n    zoom,\n    rotation,\n    viewportSize,\n    offset,\n    fixedCropArea,\n    crop,\n    naturalSize\n  } = params;\n  const {\n    cos: cos2,\n    sin: sin2\n  } = getRotationTransform(rotation);\n  if (fixedCropArea && crop && naturalSize) {\n    const aabb2 = computeAABB(naturalSize, zoom, cos2, sin2);\n    const center = getViewportCenter(viewportSize);\n    const cropRight = crop.x + crop.width;\n    const cropBottom = crop.y + crop.height;\n    const minPoint2 = {\n      x: cropRight - center.x - aabb2.width / 2,\n      y: cropBottom - center.y - aabb2.height / 2\n    };\n    const maxPoint2 = {\n      x: crop.x - center.x + aabb2.width / 2,\n      y: crop.y - center.y + aabb2.height / 2\n    };\n    return clampPoint(offset, minPoint2, maxPoint2);\n  }\n  const aabb = computeAABB(viewportSize, zoom, cos2, sin2);\n  const extraWidth = max(0, aabb.width - viewportSize.width);\n  const extraHeight = max(0, aabb.height - viewportSize.height);\n  const minPoint = {\n    x: -extraWidth / 2,\n    y: -extraHeight / 2\n  };\n  const maxPoint = {\n    x: extraWidth / 2,\n    y: extraHeight / 2\n  };\n  return clampPoint(offset, minPoint, maxPoint);\n}\nvar expandLeft = (crop, step, maxWidth) => {\n  const newX = max(0, crop.x - step);\n  const newWidth = crop.width + (crop.x - newX);\n  if (newWidth <= maxWidth) {\n    return {\n      x: newX,\n      width: newWidth\n    };\n  }\n  return {\n    x: crop.x + crop.width - maxWidth,\n    width: maxWidth\n  };\n};\nvar expandTop = (crop, step, maxHeight) => {\n  const newY = max(0, crop.y - step);\n  const newHeight = crop.height + (crop.y - newY);\n  if (newHeight <= maxHeight) {\n    return {\n      y: newY,\n      height: newHeight\n    };\n  }\n  return {\n    y: crop.y + crop.height - maxHeight,\n    height: maxHeight\n  };\n};\nvar shrinkFromLeft = (crop, step, minWidth) => {\n  const newX = min(crop.x + step, crop.x + crop.width - minWidth);\n  return {\n    x: newX,\n    width: crop.width - (newX - crop.x)\n  };\n};\nvar shrinkFromTop = (crop, step, minHeight) => {\n  const newY = min(crop.y + step, crop.y + crop.height - minHeight);\n  return {\n    y: newY,\n    height: crop.height - (newY - crop.y)\n  };\n};\nfunction computeKeyboardCrop(key, handlePosition, step, crop, viewportRect, minSize, maxSize) {\n  const nextCrop = {\n    ...crop\n  };\n  const {\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight\n  } = resolveSizeLimits({\n    minSize,\n    maxSize,\n    viewportSize: viewportRect\n  });\n  const isCorner = isCornerHandle(handlePosition);\n  if (key === \"ArrowLeft\") {\n    if (isLeftHandle(handlePosition)) {\n      const expanded = expandLeft(crop, step, maxWidth);\n      nextCrop.x = expanded.x;\n      nextCrop.width = expanded.width;\n      if (isCorner && isTopHandle(handlePosition)) {\n        const expandedY = expandTop(crop, step, maxHeight);\n        nextCrop.y = expandedY.y;\n        nextCrop.height = expandedY.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        const newHeight = nextCrop.height + step;\n        nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      }\n    } else if (isRightHandle(handlePosition)) {\n      nextCrop.width = max(minWidth, nextCrop.width - step);\n      if (isCorner && isTopHandle(handlePosition)) {\n        const shrunk = shrinkFromTop(crop, step, minHeight);\n        nextCrop.y = shrunk.y;\n        nextCrop.height = shrunk.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        nextCrop.height = max(minHeight, nextCrop.height - step);\n      }\n    }\n  } else if (key === \"ArrowRight\") {\n    if (isLeftHandle(handlePosition)) {\n      const shrunk = shrinkFromLeft(crop, step, minWidth);\n      nextCrop.x = shrunk.x;\n      nextCrop.width = shrunk.width;\n      if (isCorner && isTopHandle(handlePosition)) {\n        const shrunkY = shrinkFromTop(crop, step, minHeight);\n        nextCrop.y = shrunkY.y;\n        nextCrop.height = shrunkY.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        nextCrop.height = max(minHeight, nextCrop.height - step);\n      }\n    } else if (isRightHandle(handlePosition)) {\n      const newWidth = nextCrop.width + step;\n      nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      if (isCorner && isTopHandle(handlePosition)) {\n        const expanded = expandTop(crop, step, maxHeight);\n        nextCrop.y = expanded.y;\n        nextCrop.height = expanded.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        const newHeight = nextCrop.height + step;\n        nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      }\n    }\n  }\n  if (key === \"ArrowUp\") {\n    if (isTopHandle(handlePosition)) {\n      const expanded = expandTop(crop, step, maxHeight);\n      nextCrop.y = expanded.y;\n      nextCrop.height = expanded.height;\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const expandedX = expandLeft(crop, step, maxWidth);\n        nextCrop.x = expandedX.x;\n        nextCrop.width = expandedX.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        const newWidth = nextCrop.width + step;\n        nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      }\n    } else if (isBottomHandle(handlePosition)) {\n      nextCrop.height = max(minHeight, nextCrop.height - step);\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const shrunk = shrinkFromLeft(crop, step, minWidth);\n        nextCrop.x = shrunk.x;\n        nextCrop.width = shrunk.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        nextCrop.width = max(minWidth, nextCrop.width - step);\n      }\n    }\n  } else if (key === \"ArrowDown\") {\n    if (isTopHandle(handlePosition)) {\n      const shrunk = shrinkFromTop(crop, step, minHeight);\n      nextCrop.y = shrunk.y;\n      nextCrop.height = shrunk.height;\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const shrunkX = shrinkFromLeft(crop, step, minWidth);\n        nextCrop.x = shrunkX.x;\n        nextCrop.width = shrunkX.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        nextCrop.width = max(minWidth, nextCrop.width - step);\n      }\n    } else if (isBottomHandle(handlePosition)) {\n      const newHeight = nextCrop.height + step;\n      nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const expanded = expandLeft(crop, step, maxWidth);\n        nextCrop.x = expanded.x;\n        nextCrop.width = expanded.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        const newWidth = nextCrop.width + step;\n        nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      }\n    }\n  }\n  return nextCrop;\n}\nfunction getKeyboardMoveDelta(key, step) {\n  switch (key) {\n    case \"ArrowLeft\":\n      return {\n        x: -step,\n        y: 0\n      };\n    case \"ArrowRight\":\n      return {\n        x: step,\n        y: 0\n      };\n    case \"ArrowUp\":\n      return {\n        x: 0,\n        y: -step\n      };\n    case \"ArrowDown\":\n      return {\n        x: 0,\n        y: step\n      };\n    default:\n      return ZERO_POINT;\n  }\n}\nvar resolveCropAspectRatio = (shape, aspectRatio) => shape === \"circle\" ? 1 : aspectRatio;\nvar getCropSizeLimits = prop => ({\n  minSize: {\n    width: prop(\"minWidth\"),\n    height: prop(\"minHeight\")\n  },\n  maxSize: {\n    width: prop(\"maxWidth\"),\n    height: prop(\"maxHeight\")\n  }\n});\nvar getNudgeStep = (prop, modifiers) => {\n  if (modifiers.ctrlKey || modifiers.metaKey) return prop(\"nudgeStepCtrl\");\n  if (modifiers.shiftKey) return prop(\"nudgeStepShift\");\n  return prop(\"nudgeStep\");\n};\nvar DEFAULT_VIEWPORT_FILL = 0.8;\nvar computeDefaultCropDimensions = (viewportRect, aspectRatio, fixedCropArea) => {\n  const targetWidth = viewportRect.width * DEFAULT_VIEWPORT_FILL;\n  const targetHeight = viewportRect.height * DEFAULT_VIEWPORT_FILL;\n  if (typeof aspectRatio === \"number\" && aspectRatio > 0) {\n    if (fixedCropArea) {\n      let height2 = viewportRect.height;\n      let width2 = height2 * aspectRatio;\n      if (width2 > viewportRect.width) {\n        width2 = viewportRect.width;\n        height2 = width2 / aspectRatio;\n      }\n      return {\n        width: width2,\n        height: height2\n      };\n    }\n    const targetAspect = targetWidth / targetHeight;\n    if (aspectRatio > targetAspect) {\n      const width2 = targetWidth;\n      const height2 = width2 / aspectRatio;\n      return {\n        width: width2,\n        height: height2\n      };\n    }\n    const height = targetHeight;\n    const width = height * aspectRatio;\n    return {\n      width,\n      height\n    };\n  }\n  if (fixedCropArea) {\n    const size = min(viewportRect.width, viewportRect.height);\n    return {\n      width: size,\n      height: size\n    };\n  }\n  return {\n    width: targetWidth,\n    height: targetHeight\n  };\n};\nvar normalizeFlipState = (nextFlip, currentFlip) => {\n  if (!nextFlip) return currentFlip;\n  return {\n    horizontal: isBoolean(nextFlip.horizontal) ? nextFlip.horizontal : currentFlip.horizontal,\n    vertical: isBoolean(nextFlip.vertical) ? nextFlip.vertical : currentFlip.vertical\n  };\n};\nvar isEqualFlip = (a, b) => {\n  return a.horizontal === b.horizontal && a.vertical === b.vertical;\n};\nvar isVisibleRect = rect => rect.width > 0 && rect.height > 0;\nvar getCenterPoint = rect => ({\n  x: rect.x + rect.width / 2,\n  y: rect.y + rect.height / 2\n});\nvar getViewportCenter = size => ({\n  x: size.width / 2,\n  y: size.height / 2\n});\nvar centerRect = (size, viewport) => ({\n  x: max(0, (viewport.width - size.width) / 2),\n  y: max(0, (viewport.height - size.height) / 2)\n});\nvar getMidpoint = (p1, p2, offset = ZERO_POINT) => ({\n  x: (p1.x + p2.x) / 2 - offset.x,\n  y: (p1.y + p2.y) / 2 - offset.y\n});\nvar getMaxBounds = (cropSize, viewportSize) => ({\n  x: max(0, viewportSize.width - cropSize.width),\n  y: max(0, viewportSize.height - cropSize.height)\n});\nvar isSameSize = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar ZERO_POINT = {\n  x: 0,\n  y: 0\n};\nvar getTouchDistance = (p1, p2) => {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  return hypot(dx, dy);\n};\nvar clampPoint = (point, min2, max2) => ({\n  x: clampValue(point.x, min2.x, max2.x),\n  y: clampValue(point.y, min2.y, max2.y)\n});\nvar subtractPoints = (a, b) => ({\n  x: a.x - b.x,\n  y: a.y - b.y\n});\nvar addPoints = (a, b) => ({\n  x: a.x + b.x,\n  y: a.y + b.y\n});\nvar roundRect = rect => ({\n  x: round(rect.x),\n  y: round(rect.y),\n  width: round(rect.width),\n  height: round(rect.height)\n});\nvar scaleRect = (rect, scale) => ({\n  x: rect.x * scale.x,\n  y: rect.y * scale.y,\n  width: rect.width * scale.x,\n  height: rect.height * scale.y\n});\nvar getRotationTransform = rotation => {\n  const theta = rotation % 360 * PI / 180;\n  return {\n    cos: abs(cos(theta)),\n    sin: abs(sin(theta))\n  };\n};\nvar computeAABB = (size, zoom, cos2, sin2) => {\n  const w = size.width * zoom;\n  const h = size.height * zoom;\n  return {\n    width: w * cos2 + h * sin2,\n    height: w * sin2 + h * cos2\n  };\n};\nvar scaleSize = (size, scale) => ({\n  width: size.width * scale,\n  height: size.height * scale\n});\n\n// src/image-cropper.connect.ts\nfunction connect(service, normalize) {\n  const {\n    scope,\n    send,\n    context,\n    prop,\n    state,\n    computed\n  } = service;\n  const dragging = state.matches(\"dragging\");\n  const panning = state.matches(\"panning\");\n  const translations = prop(\"translations\");\n  const fixedCropArea = prop(\"fixedCropArea\");\n  const cropShape = prop(\"cropShape\");\n  const zoom = context.get(\"zoom\");\n  const rotation = context.get(\"rotation\");\n  const flip = context.get(\"flip\");\n  const crop = context.get(\"crop\");\n  const offset = context.get(\"offset\");\n  const naturalSize = context.get(\"naturalSize\");\n  const viewportRect = context.get(\"viewportRect\");\n  const isImageReady = computed(\"isImageReady\");\n  const isMeasured = computed(\"isMeasured\");\n  const roundedCrop = roundRect(crop);\n  const shouldIgnoreTouchPointer = event => {\n    if (event.pointerType !== \"touch\") return false;\n    const isSecondaryTouch = event.isPrimary === false;\n    const pinchActive = context.get(\"pinchDistance\") != null;\n    return isSecondaryTouch || pinchActive;\n  };\n  return {\n    zoom,\n    rotation,\n    flip,\n    crop,\n    offset,\n    naturalSize,\n    viewportRect,\n    dragging,\n    panning,\n    setZoom(value) {\n      send({\n        type: \"SET_ZOOM\",\n        zoom: value\n      });\n    },\n    zoomBy(delta) {\n      send({\n        type: \"SET_ZOOM\",\n        zoom: zoom + delta\n      });\n    },\n    setRotation(value) {\n      send({\n        type: \"SET_ROTATION\",\n        rotation: value\n      });\n    },\n    rotateBy(degrees) {\n      send({\n        type: \"SET_ROTATION\",\n        rotation: rotation + degrees\n      });\n    },\n    setFlip(nextFlip) {\n      if (!nextFlip) return;\n      const normalized = normalizeFlipState(nextFlip, flip);\n      if (isEqualFlip(normalized, flip)) return;\n      send({\n        type: \"SET_FLIP\",\n        flip: normalized\n      });\n    },\n    flipHorizontally(value) {\n      const nextValue = typeof value === \"boolean\" ? value : !flip.horizontal;\n      if (nextValue === flip.horizontal) return;\n      send({\n        type: \"SET_FLIP\",\n        flip: {\n          horizontal: nextValue\n        }\n      });\n    },\n    flipVertically(value) {\n      const nextValue = typeof value === \"boolean\" ? value : !flip.vertical;\n      if (nextValue === flip.vertical) return;\n      send({\n        type: \"SET_FLIP\",\n        flip: {\n          vertical: nextValue\n        }\n      });\n    },\n    resize(handlePosition, delta) {\n      if (!handlePosition) return;\n      if (fixedCropArea) return;\n      let deltaX = 0;\n      let deltaY = 0;\n      if (isLeftHandle(handlePosition)) {\n        deltaX = -delta;\n      } else if (isRightHandle(handlePosition)) {\n        deltaX = delta;\n      }\n      if (isTopHandle(handlePosition)) {\n        deltaY = -delta;\n      } else if (isBottomHandle(handlePosition)) {\n        deltaY = delta;\n      }\n      send({\n        type: \"RESIZE_CROP\",\n        handlePosition,\n        delta: {\n          x: deltaX,\n          y: deltaY\n        }\n      });\n    },\n    reset() {\n      send({\n        type: \"RESET\"\n      });\n    },\n    getCropData() {\n      const scale = naturalSize.width / viewportRect.width;\n      const naturalX = (crop.x - offset.x) * scale;\n      const naturalY = (crop.y - offset.y) * scale;\n      const naturalWidth = crop.width * scale;\n      const naturalHeight = crop.height * scale;\n      return {\n        x: Math.round(naturalX),\n        y: Math.round(naturalY),\n        width: Math.round(naturalWidth),\n        height: Math.round(naturalHeight),\n        rotate: rotation,\n        flipX: flip.horizontal,\n        flipY: flip.vertical\n      };\n    },\n    async getCroppedImage(options = {}) {\n      const {\n        type = \"image/png\",\n        quality = 1,\n        output = \"blob\"\n      } = options;\n      if (!isVisibleRect(naturalSize)) return null;\n      const canvas = drawCroppedImageToCanvas(service);\n      if (!canvas) return null;\n      if (output === \"dataUrl\") {\n        return canvas.toDataURL(type, quality);\n      }\n      return new Promise(resolve => {\n        canvas.toBlob(blob => {\n          resolve(blob);\n        }, type, quality);\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"aria-roledescription\": translations.rootRoleDescription,\n        \"aria-label\": translations.rootLabel,\n        \"aria-description\": isImageReady ? translations.previewDescription({\n          crop: roundedCrop,\n          zoom: Number.isFinite(zoom) ? zoom : null,\n          rotation: Number.isFinite(rotation) ? rotation : null\n        }) : translations.previewLoading,\n        \"aria-live\": \"polite\",\n        \"aria-controls\": `${getViewportId(scope)} ${getSelectionId(scope)}`,\n        \"aria-busy\": isImageReady ? void 0 : \"true\",\n        \"data-fixed\": dataAttr(fixedCropArea),\n        \"data-shape\": cropShape,\n        \"data-pinch\": dataAttr(context.get(\"pinchDistance\") != null),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          \"--crop-width\": toPx(crop.width),\n          \"--crop-height\": toPx(crop.height),\n          \"--crop-x\": toPx(crop.x),\n          \"--crop-y\": toPx(crop.y),\n          \"--image-zoom\": zoom,\n          \"--image-rotation\": rotation,\n          \"--image-offset-x\": toPx(offset.x),\n          \"--image-offset-y\": toPx(offset.y)\n        }\n      });\n    },\n    getViewportProps() {\n      const viewportId = getViewportId(scope);\n      return normalize.element({\n        ...parts.viewport.attrs,\n        id: viewportId,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        \"data-disabled\": dataAttr(!!fixedCropArea),\n        style: {\n          position: \"relative\",\n          overflow: \"hidden\",\n          touchAction: \"none\",\n          userSelect: \"none\"\n        },\n        onPointerDown(event) {\n          if (event.pointerType === \"mouse\" && event.button !== 0) return;\n          if (shouldIgnoreTouchPointer(event)) return;\n          const target = getEventTarget(event);\n          const rootEl = getRootEl(scope);\n          if (!target || !rootEl || !contains(rootEl, target)) return;\n          const selectionEl = getSelectionEl(scope);\n          if (!fixedCropArea && contains(selectionEl, target)) return;\n          const handleEl = target.closest('[data-scope=\"image-cropper\"][data-part=\"handle\"]');\n          if (handleEl && contains(rootEl, handleEl)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"PAN_POINTER_DOWN\",\n            point\n          });\n        }\n      });\n    },\n    getImageProps() {\n      const flipHorizontal = flip.horizontal;\n      const flipVertical = flip.vertical;\n      const translate = `translate(${toPx(offset.x)}, ${toPx(offset.y)})`;\n      const rotate = `rotate(${rotation}deg)`;\n      const scaleX = zoom * (flipHorizontal ? -1 : 1);\n      const scaleY = zoom * (flipVertical ? -1 : 1);\n      const scale = `scale(${scaleX}, ${scaleY})`;\n      return normalize.element({\n        ...parts.image.attrs,\n        id: getImageId(scope),\n        draggable: false,\n        role: \"presentation\",\n        alt: \"\",\n        \"aria-hidden\": true,\n        \"data-ownedby\": getViewportId(scope),\n        \"data-ready\": dataAttr(isImageReady),\n        \"data-flip-horizontal\": dataAttr(flipHorizontal),\n        \"data-flip-vertical\": dataAttr(flipVertical),\n        onLoad(event) {\n          const imageEl = event.currentTarget;\n          if (!imageEl?.complete) return;\n          const {\n            naturalWidth: width,\n            naturalHeight: height\n          } = imageEl;\n          send({\n            type: \"SET_NATURAL_SIZE\",\n            src: \"element\",\n            size: {\n              width,\n              height\n            }\n          });\n        },\n        style: {\n          pointerEvents: \"none\",\n          userSelect: \"none\",\n          transform: `${translate} ${rotate} ${scale}`,\n          willChange: \"transform\"\n        }\n      });\n    },\n    getSelectionProps() {\n      const disabled = !!fixedCropArea;\n      return normalize.element({\n        ...parts.selection.attrs,\n        id: getSelectionId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        role: \"slider\",\n        \"aria-label\": translations.selectionLabel({\n          shape: cropShape\n        }),\n        \"aria-roledescription\": translations.selectionRoleDescription,\n        \"aria-disabled\": disabled ? \"true\" : void 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": isVisibleRect(viewportRect) ? Math.max(0, Math.round(viewportRect.width - crop.width)) : Math.max(roundedCrop.x, 0),\n        \"aria-valuenow\": roundedCrop.x,\n        \"aria-valuetext\": translations.selectionValueText({\n          shape: cropShape,\n          ...roundedCrop\n        }),\n        \"aria-description\": translations.selectionInstructions,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-shape\": cropShape,\n        \"data-measured\": dataAttr(isMeasured),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          position: \"absolute\",\n          top: \"var(--crop-y)\",\n          left: \"var(--crop-x)\",\n          width: \"var(--crop-width)\",\n          height: \"var(--crop-height)\",\n          touchAction: \"none\",\n          visibility: isMeasured ? void 0 : \"hidden\"\n        },\n        onPointerDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (shouldIgnoreTouchPointer(event)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            point\n          });\n        },\n        onKeyDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (event.defaultPrevented) return;\n          const src = \"selection\";\n          const {\n            shiftKey,\n            ctrlKey,\n            metaKey,\n            altKey\n          } = event;\n          const key = getEventKey(event, {\n            dir: prop(\"dir\")\n          });\n          const isZoomInKey = key === \"+\" || key === \"=\";\n          const isZoomOutKey = key === \"-\" || key === \"_\";\n          if (isZoomInKey || isZoomOutKey) {\n            const delta = isZoomInKey ? -1 : 1;\n            send({\n              type: \"ZOOM\",\n              trigger: \"keyboard\",\n              delta\n            });\n            event.preventDefault();\n            return;\n          }\n          if (altKey && (key === \"ArrowUp\" || key === \"ArrowDown\" || key === \"ArrowLeft\" || key === \"ArrowRight\")) {\n            const handlePosition = key === \"ArrowUp\" || key === \"ArrowDown\" ? \"s\" : \"e\";\n            send({\n              type: \"NUDGE_RESIZE_CROP\",\n              handlePosition,\n              key,\n              src,\n              shiftKey,\n              ctrlKey,\n              metaKey\n            });\n            event.preventDefault();\n            return;\n          }\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"NUDGE_MOVE_CROP\",\n                key: \"ArrowUp\",\n                src,\n                shiftKey,\n                ctrlKey,\n                metaKey\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"NUDGE_MOVE_CROP\",\n                key: \"ArrowDown\",\n                src,\n                shiftKey,\n                ctrlKey,\n                metaKey\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"NUDGE_MOVE_CROP\",\n                key: \"ArrowLeft\",\n                src,\n                shiftKey,\n                ctrlKey,\n                metaKey\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"NUDGE_MOVE_CROP\",\n                key: \"ArrowRight\",\n                src,\n                shiftKey,\n                ctrlKey,\n                metaKey\n              });\n            }\n          };\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getHandleProps(props2) {\n      const handlePosition = props2.position;\n      const disabled = !!fixedCropArea;\n      return normalize.element({\n        ...parts.handle.attrs,\n        id: getHandleId(scope, handlePosition),\n        \"data-position\": handlePosition,\n        \"aria-hidden\": \"true\",\n        role: \"presentation\",\n        \"data-disabled\": dataAttr(disabled),\n        style: getHandlePositionStyles(handlePosition),\n        onPointerDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (shouldIgnoreTouchPointer(event)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            point,\n            handlePosition\n          });\n        }\n      });\n    },\n    getGridProps(props2) {\n      const axis = props2.axis;\n      const isMeasured2 = computed(\"isMeasured\");\n      return normalize.element({\n        ...parts.grid.attrs,\n        \"aria-hidden\": \"true\",\n        \"data-axis\": axis,\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          position: \"absolute\",\n          inset: axis === \"horizontal\" ? \"33.33% 0\" : \"0 33.33%\",\n          pointerEvents: \"none\",\n          visibility: isMeasured2 ? void 0 : \"hidden\"\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      minWidth: 40,\n      minHeight: 40,\n      maxWidth: Number.POSITIVE_INFINITY,\n      maxHeight: Number.POSITIVE_INFINITY,\n      defaultZoom: 1,\n      zoomStep: 0.1,\n      zoomSensitivity: 2,\n      minZoom: 1,\n      maxZoom: 5,\n      defaultRotation: 0,\n      defaultFlip: {\n        horizontal: false,\n        vertical: false\n      },\n      fixedCropArea: false,\n      cropShape: \"rectangle\",\n      nudgeStep: 1,\n      nudgeStepShift: 10,\n      nudgeStepCtrl: 50,\n      ...props2,\n      translations: {\n        rootLabel: \"Image cropper\",\n        rootRoleDescription: \"Image cropper\",\n        previewLoading: \"Image cropper preview loading\",\n        previewDescription({\n          crop,\n          zoom,\n          rotation\n        }) {\n          const zoomText = zoom != null && Number.isFinite(zoom) ? `${zoom.toFixed(2)}x zoom` : \"default zoom\";\n          const rotationText = rotation != null && Number.isFinite(rotation) ? `${Math.round(rotation)} degrees rotation` : \"0 degrees rotation\";\n          return `Image cropper preview, ${zoomText}, ${rotationText}. Crop positioned at ${crop.x}px from the left and ${crop.y}px from the top with a size of ${crop.width}px by ${crop.height}px.`;\n        },\n        selectionLabel: ({\n          shape\n        }) => `Crop selection area (${shape === \"circle\" ? \"circle\" : \"rectangle\"})`,\n        selectionRoleDescription: \"2d slider\",\n        selectionInstructions: \"Use arrow keys to move the crop. Hold Alt with arrow keys to resize width or height. Press plus or minus to zoom.\",\n        selectionValueText({\n          shape,\n          x,\n          y,\n          width,\n          height\n        }) {\n          if (shape === \"circle\") {\n            return `Position X ${x}px, Y ${y}px. Diameter ${width}px.`;\n          }\n          return `Position X ${x}px, Y ${y}px. Size ${width}px by ${height}px.`;\n        },\n        ...props2.translations\n      }\n    };\n  },\n  context({\n    bindable,\n    prop\n  }) {\n    return {\n      naturalSize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      crop: bindable(() => ({\n        defaultValue: {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        },\n        onChange(crop) {\n          prop(\"onCropChange\")?.({\n            crop\n          });\n        }\n      })),\n      pointerStart: bindable(() => ({\n        defaultValue: null\n      })),\n      cropStart: bindable(() => ({\n        defaultValue: null\n      })),\n      handlePosition: bindable(() => ({\n        defaultValue: null\n      })),\n      shiftLockRatio: bindable(() => ({\n        defaultValue: null\n      })),\n      pinchDistance: bindable(() => ({\n        defaultValue: null\n      })),\n      pinchMidpoint: bindable(() => ({\n        defaultValue: null\n      })),\n      zoom: bindable(() => ({\n        defaultValue: prop(\"zoom\") ?? prop(\"defaultZoom\"),\n        onChange(zoom) {\n          prop(\"onZoomChange\")?.({\n            zoom\n          });\n        }\n      })),\n      rotation: bindable(() => ({\n        defaultValue: prop(\"defaultRotation\"),\n        value: prop(\"rotation\"),\n        onChange(rotation) {\n          prop(\"onRotationChange\")?.({\n            rotation\n          });\n        }\n      })),\n      flip: bindable(() => {\n        const defaultFlip = prop(\"defaultFlip\");\n        return {\n          defaultValue: {\n            ...defaultFlip\n          },\n          value: prop(\"flip\"),\n          onChange(flip) {\n            prop(\"onFlipChange\")?.({\n              flip\n            });\n          }\n        };\n      }),\n      offset: bindable(() => ({\n        defaultValue: ZERO_POINT\n      })),\n      offsetStart: bindable(() => ({\n        defaultValue: null\n      })),\n      viewportRect: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0,\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        }\n      }))\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  on: {\n    PINCH_START: {\n      actions: [\"setPinchDistance\"]\n    },\n    PINCH_MOVE: {\n      actions: [\"handlePinchMove\"]\n    },\n    PINCH_END: {\n      actions: [\"clearPinchDistance\"]\n    },\n    SET_ZOOM: {\n      actions: [\"updateZoom\"]\n    },\n    SET_ROTATION: {\n      actions: [\"setRotation\"]\n    },\n    SET_FLIP: {\n      actions: [\"setFlip\"]\n    },\n    RESIZE_CROP: {\n      guard: \"canResizeCrop\",\n      actions: [\"resizeCrop\"]\n    },\n    VIEWPORT_RESIZE: {\n      actions: [\"resizeViewport\"]\n    },\n    RESET: {\n      actions: [\"resetToInitialState\"]\n    }\n  },\n  computed: {\n    isMeasured: ({\n      context\n    }) => isVisibleRect(context.get(\"viewportRect\")) && isVisibleRect(context.get(\"crop\")),\n    isImageReady: ({\n      context\n    }) => isVisibleRect(context.get(\"naturalSize\"))\n  },\n  watch({\n    track,\n    context,\n    prop,\n    send\n  }) {\n    track([() => prop(\"zoom\")], () => {\n      const propZoom = prop(\"zoom\");\n      if (propZoom === void 0) return;\n      const currentZoom = context.get(\"zoom\");\n      if (propZoom === currentZoom) return;\n      send({\n        type: \"SET_ZOOM\",\n        zoom: propZoom,\n        src: \"prop\"\n      });\n    });\n  },\n  states: {\n    idle: {\n      entry: [\"checkImageStatus\"],\n      effects: [\"trackViewportResize\", \"trackWheelEvent\", \"trackTouchEvents\"],\n      on: {\n        SET_NATURAL_SIZE: {\n          actions: [\"setNaturalSize\"]\n        },\n        SET_DEFAULT_CROP: {\n          actions: [\"setDefaultCrop\"]\n        },\n        POINTER_DOWN: {\n          guard: \"canDragSelection\",\n          target: \"dragging\",\n          actions: [\"setPointerStart\", \"setCropStart\", \"setHandlePosition\"]\n        },\n        PAN_POINTER_DOWN: {\n          guard: \"canPan\",\n          target: \"panning\",\n          actions: [\"setPointerStart\", \"setOffsetStart\"]\n        },\n        ZOOM: {\n          guard: \"hasViewportRect\",\n          actions: [\"updateZoom\"]\n        },\n        NUDGE_RESIZE_CROP: {\n          guard: \"hasViewportRect\",\n          actions: [\"nudgeResizeCrop\"]\n        },\n        NUDGE_MOVE_CROP: {\n          guard: \"hasViewportRect\",\n          actions: [\"nudgeMoveCrop\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"updateCrop\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"clearPointerStart\", \"clearCropStart\", \"clearHandlePosition\", \"clearOffsetStart\", \"clearShiftRatio\"]\n        }\n      }\n    },\n    panning: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"updatePanOffset\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"clearPointerStart\", \"clearOffsetStart\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      hasViewportRect({\n        context\n      }) {\n        return isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canResizeCrop({\n        context,\n        prop\n      }) {\n        return !prop(\"fixedCropArea\") && isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canPan({\n        context\n      }) {\n        return isVisibleRect(context.get(\"naturalSize\")) && isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canDragSelection({\n        context,\n        prop\n      }) {\n        return isVisibleRect(context.get(\"viewportRect\")) && !prop(\"fixedCropArea\");\n      }\n    },\n    actions: {\n      checkImageStatus({\n        send,\n        scope,\n        context\n      }) {\n        const naturalSize = context.get(\"naturalSize\");\n        const imageEl = getImageEl(scope);\n        if (!imageEl?.complete) return;\n        const {\n          naturalWidth: width,\n          naturalHeight: height\n        } = imageEl;\n        if (isVisibleRect({\n          width,\n          height\n        }) && !isVisibleRect(naturalSize)) {\n          send({\n            type: \"SET_NATURAL_SIZE\",\n            src: \"ssr\",\n            size: {\n              width,\n              height\n            }\n          });\n        }\n      },\n      setNaturalSize({\n        event,\n        context,\n        send\n      }) {\n        context.set(\"naturalSize\", event.size);\n        send({\n          type: \"SET_DEFAULT_CROP\",\n          src: \"init\"\n        });\n      },\n      setDefaultCrop({\n        context,\n        prop,\n        scope\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const viewportRect = getBoundingRect(viewportEl);\n        if (!isVisibleRect(viewportRect)) return;\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const {\n          minSize,\n          maxSize\n        } = getCropSizeLimits(prop);\n        const clampSize = rect => {\n          const result = computeResizeCrop({\n            cropStart: rect,\n            handlePosition: \"se\",\n            delta: ZERO_POINT,\n            viewportRect,\n            minSize,\n            maxSize,\n            aspectRatio\n          });\n          return {\n            width: result.width,\n            height: result.height\n          };\n        };\n        const initialCrop = prop(\"initialCrop\");\n        if (initialCrop) {\n          const constrainedSize2 = clampSize({\n            x: 0,\n            y: 0,\n            width: initialCrop.width,\n            height: initialCrop.height\n          });\n          const {\n            width: width2,\n            height: height2\n          } = constrainedSize2;\n          const max2 = getMaxBounds({\n            width: width2,\n            height: height2\n          }, viewportRect);\n          const {\n            x: x2,\n            y: y2\n          } = clampPoint(initialCrop, ZERO_POINT, max2);\n          context.set(\"crop\", {\n            x: x2,\n            y: y2,\n            width: width2,\n            height: height2\n          });\n          return;\n        }\n        const fixedCropArea = prop(\"fixedCropArea\");\n        const defaultSize = computeDefaultCropDimensions(viewportRect, aspectRatio, fixedCropArea);\n        const constrainedSize = clampSize({\n          x: 0,\n          y: 0,\n          width: defaultSize.width,\n          height: defaultSize.height\n        });\n        const width = constrainedSize.width;\n        const height = constrainedSize.height;\n        const {\n          x,\n          y\n        } = centerRect({\n          width,\n          height\n        }, viewportRect);\n        context.set(\"crop\", {\n          x,\n          y,\n          width,\n          height\n        });\n        context.set(\"viewportRect\", viewportRect);\n      },\n      setPointerStart({\n        event,\n        context\n      }) {\n        const point = event.point;\n        if (!point) return;\n        context.set(\"pointerStart\", point);\n      },\n      setOffsetStart({\n        context\n      }) {\n        const offset = context.get(\"offset\");\n        context.set(\"offsetStart\", {\n          ...offset\n        });\n      },\n      setCropStart({\n        context\n      }) {\n        const crop = context.get(\"crop\");\n        context.set(\"cropStart\", crop);\n      },\n      updateCrop({\n        context,\n        event,\n        prop\n      }) {\n        const handlePosition = context.get(\"handlePosition\");\n        const pointerStart = context.get(\"pointerStart\");\n        const cropStart = context.get(\"cropStart\");\n        const viewportRect = context.get(\"viewportRect\");\n        const cropShape = prop(\"cropShape\");\n        const aspectRatioProp = prop(\"aspectRatio\");\n        let aspectRatio = resolveCropAspectRatio(cropShape, aspectRatioProp);\n        const {\n          minSize,\n          maxSize\n        } = getCropSizeLimits(prop);\n        if (!pointerStart || !cropStart) return;\n        const currentPoint = event.point;\n        const delta = subtractPoints(currentPoint, pointerStart);\n        let nextCrop;\n        if (handlePosition) {\n          const allowShiftLock = typeof aspectRatioProp === \"undefined\" && cropShape !== \"circle\";\n          if (allowShiftLock) {\n            if (event.shiftKey) {\n              const currentCrop = context.get(\"crop\");\n              const w = currentCrop.width;\n              const h = currentCrop.height;\n              if (w > 0 && h > 0) {\n                const ratio = w / h;\n                if (ratio > 0) context.set(\"shiftLockRatio\", ratio);\n              }\n              const lockRatio = context.get(\"shiftLockRatio\");\n              if (lockRatio !== null && lockRatio > 0) aspectRatio = lockRatio;\n            } else {\n              context.set(\"shiftLockRatio\", null);\n            }\n          } else {\n            context.set(\"shiftLockRatio\", null);\n          }\n          nextCrop = computeResizeCrop({\n            cropStart,\n            handlePosition,\n            delta,\n            viewportRect,\n            minSize,\n            maxSize,\n            aspectRatio\n          });\n        } else {\n          nextCrop = computeMoveCrop(cropStart, delta, viewportRect);\n        }\n        context.set(\"crop\", nextCrop);\n      },\n      updatePanOffset({\n        context,\n        event,\n        prop\n      }) {\n        const point = event.point;\n        const pointerStart = context.get(\"pointerStart\");\n        const offsetStart = context.get(\"offsetStart\");\n        if (!point || !pointerStart || !offsetStart) return;\n        const zoom = context.get(\"zoom\");\n        const rotation = context.get(\"rotation\");\n        const viewportRect = context.get(\"viewportRect\");\n        const delta = subtractPoints(point, pointerStart);\n        const nextOffset = clampOffset({\n          zoom,\n          rotation,\n          viewportSize: viewportRect,\n          offset: addPoints(offsetStart, delta),\n          fixedCropArea: prop(\"fixedCropArea\"),\n          crop: context.get(\"crop\"),\n          naturalSize: context.get(\"naturalSize\")\n        });\n        context.set(\"offset\", nextOffset);\n      },\n      setHandlePosition({\n        event,\n        context\n      }) {\n        const position = event.handlePosition;\n        if (!position) return;\n        context.set(\"handlePosition\", position);\n      },\n      setRotation({\n        context,\n        event\n      }) {\n        const rotation = event.rotation;\n        const nextRotation = clampValue(rotation, 0, 360);\n        context.set(\"rotation\", nextRotation);\n      },\n      setFlip({\n        context,\n        event\n      }) {\n        const nextFlip = event.flip;\n        if (!nextFlip) return;\n        const currentFlip = context.get(\"flip\");\n        const normalized = normalizeFlipState(nextFlip, currentFlip);\n        if (isEqualFlip(normalized, currentFlip)) return;\n        context.set(\"flip\", normalized);\n      },\n      resizeCrop({\n        context,\n        event,\n        prop\n      }) {\n        const {\n          handlePosition,\n          delta\n        } = event;\n        if (!handlePosition) return;\n        const viewportRect = context.get(\"viewportRect\");\n        if (!isVisibleRect(viewportRect)) return;\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const {\n          minSize,\n          maxSize\n        } = getCropSizeLimits(prop);\n        const crop = context.get(\"crop\");\n        const nextCrop = computeResizeCrop({\n          cropStart: crop,\n          handlePosition,\n          delta,\n          viewportRect,\n          minSize,\n          maxSize,\n          aspectRatio\n        });\n        context.set(\"crop\", nextCrop);\n      },\n      clearPointerStart({\n        context\n      }) {\n        context.set(\"pointerStart\", null);\n      },\n      clearCropStart({\n        context\n      }) {\n        context.set(\"cropStart\", null);\n      },\n      clearHandlePosition({\n        context\n      }) {\n        context.set(\"handlePosition\", null);\n      },\n      clearOffsetStart({\n        context\n      }) {\n        context.set(\"offsetStart\", null);\n      },\n      clearShiftRatio({\n        context\n      }) {\n        context.set(\"shiftLockRatio\", null);\n      },\n      updateZoom({\n        context,\n        event,\n        prop\n      }) {\n        let {\n          delta,\n          point,\n          zoom: targetZoom,\n          scale,\n          panDelta\n        } = event;\n        const crop = context.get(\"crop\");\n        const currentZoom = context.get(\"zoom\");\n        const currentOffset = context.get(\"offset\");\n        const rotation = context.get(\"rotation\");\n        const viewportRect = context.get(\"viewportRect\");\n        const naturalSize = context.get(\"naturalSize\");\n        const fixedCropArea = prop(\"fixedCropArea\");\n        if (!point) {\n          point = getCenterPoint(crop);\n        }\n        const step = Math.abs(prop(\"zoomStep\"));\n        const sensitivity = Math.max(0, prop(\"zoomSensitivity\"));\n        const [minZoom, maxZoom] = [prop(\"minZoom\"), prop(\"maxZoom\")];\n        const calculateNextZoom = () => {\n          if (typeof targetZoom === \"number\") {\n            return clampValue(targetZoom, minZoom, maxZoom);\n          }\n          if (event.trigger === \"touch\" && typeof scale === \"number\") {\n            const minScale = 0.5;\n            const maxScale = 2;\n            const clampedScale = clampValue(scale, minScale, maxScale);\n            const smoothing = sensitivity > 0 ? Math.pow(clampedScale, sensitivity) : clampedScale;\n            return clampValue(currentZoom * smoothing, minZoom, maxZoom);\n          }\n          if (typeof delta === \"number\") {\n            const direction = Math.sign(delta) < 0 ? 1 : -1;\n            return clampValue(currentZoom + step * direction, minZoom, maxZoom);\n          }\n          return null;\n        };\n        const applyClampedOffset = (zoom, offset) => {\n          return clampOffset({\n            zoom,\n            rotation,\n            viewportSize: viewportRect,\n            offset,\n            fixedCropArea,\n            crop,\n            naturalSize\n          });\n        };\n        const nextZoom = calculateNextZoom();\n        if (nextZoom === null) return;\n        if (nextZoom === currentZoom && panDelta) {\n          const nextOffset2 = applyClampedOffset(currentZoom, addPoints(currentOffset, panDelta));\n          context.set(\"offset\", nextOffset2);\n          return;\n        }\n        if (nextZoom === currentZoom) return;\n        const {\n          width: viewportWidth,\n          height: viewportHeight\n        } = viewportRect;\n        const {\n          x: centerX,\n          y: centerY\n        } = getViewportCenter(viewportRect);\n        const zoomRatio = nextZoom / currentZoom;\n        let nextOffset = {\n          x: (1 - zoomRatio) * (point.x - centerX) + zoomRatio * currentOffset.x,\n          y: (1 - zoomRatio) * (point.y - centerY) + zoomRatio * currentOffset.y\n        };\n        if (panDelta) {\n          nextOffset = applyClampedOffset(nextZoom, addPoints(nextOffset, panDelta));\n        } else if (nextZoom < currentZoom) {\n          if (fixedCropArea) {\n            nextOffset = applyClampedOffset(nextZoom, nextOffset);\n          } else {\n            const {\n              width: scaledImageWidth,\n              height: scaledImageHeight\n            } = scaleSize(viewportRect, nextZoom);\n            if (scaledImageWidth <= viewportWidth) {\n              nextOffset.x = 0;\n            } else {\n              const minX = viewportWidth - centerX - scaledImageWidth / 2;\n              const maxX = scaledImageWidth / 2 - centerX;\n              nextOffset.x = Math.max(minX, Math.min(maxX, nextOffset.x));\n            }\n            if (scaledImageHeight <= viewportHeight) {\n              nextOffset.y = 0;\n            } else {\n              const minY = viewportHeight - centerY - scaledImageHeight / 2;\n              const maxY = scaledImageHeight / 2 - centerY;\n              nextOffset.y = Math.max(minY, Math.min(maxY, nextOffset.y));\n            }\n          }\n        }\n        context.set(\"zoom\", nextZoom);\n        context.set(\"offset\", nextOffset);\n      },\n      setPinchDistance({\n        context,\n        event,\n        send\n      }) {\n        const touches = Array.isArray(event.touches) ? event.touches : [];\n        if (touches.length < 2) return;\n        if (context.get(\"pointerStart\") !== null) {\n          send({\n            type: \"POINTER_UP\",\n            src: \"pinch\"\n          });\n        }\n        const [first, second] = touches;\n        const distance = getTouchDistance(first, second);\n        const viewportRect = context.get(\"viewportRect\");\n        const midpoint = getMidpoint(first, second, {\n          x: viewportRect.left,\n          y: viewportRect.top\n        });\n        context.set(\"pinchDistance\", distance);\n        context.set(\"pinchMidpoint\", midpoint);\n      },\n      handlePinchMove({\n        context,\n        event,\n        send\n      }) {\n        const touches = Array.isArray(event.touches) ? event.touches : [];\n        if (touches.length < 2) return;\n        const [first, second] = touches;\n        const distance = getTouchDistance(first, second);\n        const lastDistance = context.get(\"pinchDistance\");\n        const lastMidpoint = context.get(\"pinchMidpoint\");\n        const viewportRect = context.get(\"viewportRect\");\n        const midpoint = getMidpoint(first, second, {\n          x: viewportRect.left,\n          y: viewportRect.top\n        });\n        if (lastDistance != null && lastDistance > 0 && lastMidpoint != null) {\n          const delta = lastDistance - distance;\n          const scale = distance / lastDistance;\n          const distanceChange = Math.abs(delta);\n          const hasSignificantZoom = distanceChange > 1;\n          const panDelta = subtractPoints(midpoint, lastMidpoint);\n          send({\n            type: \"ZOOM\",\n            trigger: \"touch\",\n            delta,\n            scale: hasSignificantZoom ? scale : 1,\n            point: midpoint,\n            panDelta\n          });\n        }\n        context.set(\"pinchDistance\", distance);\n        context.set(\"pinchMidpoint\", midpoint);\n      },\n      clearPinchDistance({\n        context\n      }) {\n        context.set(\"pinchDistance\", null);\n        context.set(\"pinchMidpoint\", null);\n      },\n      nudgeResizeCrop({\n        context,\n        event,\n        prop\n      }) {\n        const {\n          key,\n          handlePosition,\n          shiftKey,\n          ctrlKey,\n          metaKey\n        } = event;\n        const crop = context.get(\"crop\");\n        const viewportRect = context.get(\"viewportRect\");\n        const step = getNudgeStep(prop, {\n          shiftKey,\n          ctrlKey,\n          metaKey\n        });\n        const {\n          minSize,\n          maxSize\n        } = getCropSizeLimits(prop);\n        const nextCrop = computeKeyboardCrop(key, handlePosition, step, crop, viewportRect, minSize, maxSize);\n        context.set(\"crop\", nextCrop);\n      },\n      nudgeMoveCrop({\n        context,\n        event,\n        prop\n      }) {\n        const {\n          key,\n          shiftKey,\n          ctrlKey,\n          metaKey\n        } = event;\n        const crop = context.get(\"crop\");\n        const viewportRect = context.get(\"viewportRect\");\n        const step = getNudgeStep(prop, {\n          shiftKey,\n          ctrlKey,\n          metaKey\n        });\n        const delta = getKeyboardMoveDelta(key, step);\n        const nextCrop = computeMoveCrop(crop, delta, viewportRect);\n        context.set(\"crop\", nextCrop);\n      },\n      resizeViewport({\n        context,\n        prop,\n        scope,\n        send\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const newViewportRect = getBoundingRect(viewportEl);\n        if (!isVisibleRect(newViewportRect)) return;\n        const oldViewportRect = context.get(\"viewportRect\");\n        if (isSameSize(oldViewportRect, newViewportRect)) {\n          return;\n        }\n        context.set(\"viewportRect\", newViewportRect);\n        const oldCrop = context.get(\"crop\");\n        if (!isVisibleRect(oldViewportRect)) {\n          if (!isVisibleRect(oldCrop)) {\n            send({\n              type: \"SET_DEFAULT_CROP\",\n              src: \"viewport-resize\"\n            });\n            return;\n          }\n        }\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const {\n          minSize,\n          maxSize\n        } = getCropSizeLimits(prop);\n        const scale = {\n          x: newViewportRect.width / oldViewportRect.width,\n          y: newViewportRect.height / oldViewportRect.height\n        };\n        let newCrop = scaleRect(oldCrop, scale);\n        const constrainedCrop = computeResizeCrop({\n          cropStart: newCrop,\n          handlePosition: \"se\",\n          delta: ZERO_POINT,\n          viewportRect: newViewportRect,\n          minSize,\n          maxSize,\n          aspectRatio\n        });\n        const max2 = getMaxBounds(constrainedCrop, newViewportRect);\n        const {\n          x,\n          y\n        } = clampPoint(constrainedCrop, ZERO_POINT, max2);\n        context.set(\"crop\", {\n          x,\n          y,\n          width: constrainedCrop.width,\n          height: constrainedCrop.height\n        });\n      },\n      resetToInitialState({\n        context\n      }) {\n        context.set(\"zoom\", context.initial(\"zoom\"));\n        context.set(\"rotation\", context.initial(\"rotation\"));\n        context.set(\"flip\", context.initial(\"flip\"));\n        context.set(\"offset\", ZERO_POINT);\n        context.set(\"crop\", context.initial(\"crop\"));\n      }\n    },\n    effects: {\n      trackPointerMove({\n        scope,\n        send\n      }) {\n        function onPointerMove(event) {\n          const point = getEventPoint(event);\n          const target = getEventTarget(event);\n          send({\n            type: \"POINTER_MOVE\",\n            point,\n            target,\n            shiftKey: event.shiftKey\n          });\n        }\n        function onPointerUp() {\n          send({\n            type: \"POINTER_UP\"\n          });\n        }\n        return callAll(addDomEvent(scope.getDoc(), \"pointermove\", onPointerMove), addDomEvent(scope.getDoc(), \"pointerup\", onPointerUp));\n      },\n      trackViewportResize({\n        scope,\n        send\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        return resizeObserverBorderBox.observe(viewportEl, () => {\n          send({\n            type: \"VIEWPORT_RESIZE\",\n            src: \"resize\"\n          });\n        });\n      },\n      trackWheelEvent({\n        scope,\n        send\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        function onWheel(event) {\n          event.preventDefault();\n          if (!viewportEl) return;\n          const rect = viewportEl.getBoundingClientRect();\n          const point = {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top\n          };\n          send({\n            type: \"ZOOM\",\n            trigger: \"wheel\",\n            delta: event.deltaY,\n            point\n          });\n        }\n        return addDomEvent(viewportEl, \"wheel\", onWheel, {\n          passive: false\n        });\n      },\n      trackTouchEvents({\n        scope,\n        send\n      }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        function onTouchStart(event) {\n          if (event.touches.length >= 2) {\n            event.preventDefault();\n            const touches = Array.from(event.touches).map(touch => ({\n              x: touch.clientX,\n              y: touch.clientY\n            }));\n            send({\n              type: \"PINCH_START\",\n              touches\n            });\n          }\n        }\n        function onTouchMove(event) {\n          if (event.touches.length >= 2) {\n            event.preventDefault();\n            const touches = Array.from(event.touches).map(touch => ({\n              x: touch.clientX,\n              y: touch.clientY\n            }));\n            send({\n              type: \"PINCH_MOVE\",\n              touches\n            });\n          }\n        }\n        function onTouchEnd(event) {\n          if (event.touches.length < 2) {\n            send({\n              type: \"PINCH_END\"\n            });\n          }\n        }\n        return callAll(addDomEvent(viewportEl, \"touchstart\", onTouchStart, {\n          passive: false\n        }), addDomEvent(viewportEl, \"touchmove\", onTouchMove, {\n          passive: false\n        }), addDomEvent(viewportEl, \"touchend\", onTouchEnd));\n      }\n    }\n  }\n});\nvar getBoundingRect = el => {\n  const rect = el.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  };\n};\nvar props = createProps()([\"id\", \"ids\", \"dir\", \"getRootNode\", \"initialCrop\", \"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\", \"aspectRatio\", \"cropShape\", \"zoom\", \"rotation\", \"flip\", \"defaultZoom\", \"defaultRotation\", \"defaultFlip\", \"zoomStep\", \"zoomSensitivity\", \"minZoom\", \"maxZoom\", \"onZoomChange\", \"onRotationChange\", \"onFlipChange\", \"onCropChange\", \"fixedCropArea\", \"nudgeStep\", \"nudgeStepShift\", \"nudgeStepCtrl\", \"translations\"]);\nvar splitProps = createSplitProps(props);\nvar handles = [\"nw\", \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\"];\nexport { anatomy, connect, handles, machine, props, splitProps };","map":{"version":3,"names":["createAnatomy","addDomEvent","resizeObserverBorderBox","getEventPoint","getEventTarget","dataAttr","getEventKey","contains","callAll","clampValue","createSplitProps","isBoolean","toPx","createMachine","createProps","anatomy","parts","build","getHandlePositionStyles","handlePosition","position","cursor","width","top","left","translate","height","right","bottom","Error","getRootId","ctx","ids","root","id","getViewportId","viewport","getImageId","image","getSelectionId","selection","getHandleId","handle","getRootEl","getById","getViewportEl","getImageEl","getSelectionEl","drawCroppedImageToCanvas","params","context","scope","imageEl","complete","doc","ownerDocument","crop","get","zoom","rotation","flip","viewportRect","naturalSize","offset","canvas","createElement","getContext","save","rotate","Math","PI","scaleX","horizontal","scaleY","vertical","scale","viewportCenterX","viewportCenterY","cropCenterX","x","cropCenterY","y","deltaX","deltaY","imageCenterX","imageCenterY","sourceX","sourceY","sourceWidth","sourceHeight","drawImage","restore","min","max","abs","round","hypot","cos","sin","isLeftHandle","isRightHandle","isTopHandle","isBottomHandle","isCornerHandle","isHorizontalEdgeHandle","isVerticalEdgeHandle","hasAspectRatio","value","resolveSizeLimits","options","minSize","maxSize","viewportSize","aspectRatio","minWidth","minHeight","maxWidth","Number","isFinite","maxHeight","hasAspect","minWidthWithAspect","minHeightWithAspect","constrainedMaxWidth","constrainedMaxHeight","clampAspectSize","widthValue","heightValue","limits","constrainWidthFromHeight","clampByWidth","constrained","clampedHeight","reconstrainted","clampByHeight","adjustedHeight","byWidth","byHeight","deltaWidth","deltaHeight","applyDeltaToEdges","bounds","delta","minLeft","maxLeft","minRight","maxRight","minTop","maxTop","minBottom","maxBottom","applyAspectToHorizontalResize","centerY","nextWidth","nextHeight","halfH","newTop","newBottom","applyAspectToVerticalResize","centerX","halfW","newLeft","newRight","applyCornerResize","computeResizeCrop","cropStart","edgesAfterDelta","tempW","tempH","result","computeMoveCrop","clampOffset","fixedCropArea","cos2","sin2","getRotationTransform","aabb2","computeAABB","center","getViewportCenter","cropRight","cropBottom","minPoint2","maxPoint2","clampPoint","aabb","extraWidth","extraHeight","minPoint","maxPoint","expandLeft","step","newX","newWidth","expandTop","newY","newHeight","shrinkFromLeft","shrinkFromTop","computeKeyboardCrop","key","nextCrop","isCorner","expanded","expandedY","shrunk","shrunkY","expandedX","shrunkX","getKeyboardMoveDelta","ZERO_POINT","resolveCropAspectRatio","shape","getCropSizeLimits","prop","getNudgeStep","modifiers","ctrlKey","metaKey","shiftKey","DEFAULT_VIEWPORT_FILL","computeDefaultCropDimensions","targetWidth","targetHeight","height2","width2","targetAspect","size","normalizeFlipState","nextFlip","currentFlip","isEqualFlip","a","b","isVisibleRect","rect","getCenterPoint","centerRect","getMidpoint","p1","p2","getMaxBounds","cropSize","isSameSize","getTouchDistance","dx","dy","point","min2","max2","subtractPoints","addPoints","roundRect","scaleRect","theta","w","h","scaleSize","connect","service","normalize","send","state","computed","dragging","matches","panning","translations","cropShape","isImageReady","isMeasured","roundedCrop","shouldIgnoreTouchPointer","event","pointerType","isSecondaryTouch","isPrimary","pinchActive","setZoom","type","zoomBy","setRotation","rotateBy","degrees","setFlip","normalized","flipHorizontally","nextValue","flipVertically","resize","reset","getCropData","naturalX","naturalY","naturalWidth","naturalHeight","flipX","flipY","getCroppedImage","quality","output","toDataURL","Promise","resolve","toBlob","blob","getRootProps","element","attrs","dir","role","rootRoleDescription","rootLabel","previewDescription","previewLoading","style","getViewportProps","viewportId","overflow","touchAction","userSelect","onPointerDown","button","target","rootEl","selectionEl","handleEl","closest","getImageProps","flipHorizontal","flipVertical","draggable","alt","onLoad","currentTarget","src","pointerEvents","transform","willChange","getSelectionProps","disabled","tabIndex","selectionLabel","selectionRoleDescription","selectionValueText","selectionInstructions","visibility","preventDefault","onKeyDown","defaultPrevented","altKey","isZoomInKey","isZoomOutKey","trigger","keyMap","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","exec","getHandleProps","props2","getGridProps","axis","isMeasured2","grid","inset","machine","props","POSITIVE_INFINITY","defaultZoom","zoomStep","zoomSensitivity","minZoom","maxZoom","defaultRotation","defaultFlip","nudgeStep","nudgeStepShift","nudgeStepCtrl","zoomText","toFixed","rotationText","bindable","defaultValue","onChange","pointerStart","shiftLockRatio","pinchDistance","pinchMidpoint","offsetStart","initialState","on","PINCH_START","actions","PINCH_MOVE","PINCH_END","SET_ZOOM","SET_ROTATION","SET_FLIP","RESIZE_CROP","guard","VIEWPORT_RESIZE","RESET","watch","track","propZoom","currentZoom","states","idle","entry","effects","SET_NATURAL_SIZE","SET_DEFAULT_CROP","POINTER_DOWN","PAN_POINTER_DOWN","ZOOM","NUDGE_RESIZE_CROP","NUDGE_MOVE_CROP","POINTER_MOVE","POINTER_UP","implementations","guards","hasViewportRect","canResizeCrop","canPan","canDragSelection","checkImageStatus","setNaturalSize","set","setDefaultCrop","viewportEl","getBoundingRect","clampSize","initialCrop","constrainedSize2","x2","y2","defaultSize","constrainedSize","setPointerStart","setOffsetStart","setCropStart","updateCrop","aspectRatioProp","currentPoint","allowShiftLock","currentCrop","ratio","lockRatio","updatePanOffset","nextOffset","setHandlePosition","nextRotation","resizeCrop","clearPointerStart","clearCropStart","clearHandlePosition","clearOffsetStart","clearShiftRatio","updateZoom","targetZoom","panDelta","currentOffset","sensitivity","calculateNextZoom","minScale","maxScale","clampedScale","smoothing","pow","direction","sign","applyClampedOffset","nextZoom","nextOffset2","viewportWidth","viewportHeight","zoomRatio","scaledImageWidth","scaledImageHeight","minX","maxX","minY","maxY","setPinchDistance","touches","Array","isArray","length","first","second","distance","midpoint","handlePinchMove","lastDistance","lastMidpoint","distanceChange","hasSignificantZoom","clearPinchDistance","nudgeResizeCrop","nudgeMoveCrop","resizeViewport","newViewportRect","oldViewportRect","oldCrop","newCrop","constrainedCrop","resetToInitialState","initial","trackPointerMove","onPointerMove","onPointerUp","getDoc","trackViewportResize","observe","trackWheelEvent","onWheel","getBoundingClientRect","clientX","clientY","passive","trackTouchEvents","onTouchStart","from","map","touch","onTouchMove","onTouchEnd","el","splitProps","handles"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@zag-js/image-cropper/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, resizeObserverBorderBox, getEventPoint, getEventTarget, dataAttr, getEventKey, contains } from '@zag-js/dom-query';\nimport { callAll, clampValue, createSplitProps, isBoolean, toPx } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/image-cropper.anatomy.ts\nvar anatomy = createAnatomy(\"image-cropper\").parts(\"root\", \"viewport\", \"image\", \"selection\", \"handle\", \"grid\");\nvar parts = anatomy.build();\n\n// src/get-resize-axis-style.ts\nfunction getHandlePositionStyles(handlePosition) {\n  switch (handlePosition) {\n    case \"n\":\n      return {\n        position: \"absolute\",\n        cursor: \"n-resize\",\n        width: \"96%\",\n        top: 0,\n        left: \"50%\",\n        translate: \"-50% -50%\"\n      };\n    case \"e\":\n      return {\n        position: \"absolute\",\n        cursor: \"e-resize\",\n        height: \"96%\",\n        right: 0,\n        top: \"50%\",\n        translate: \"50% -50%\"\n      };\n    case \"s\":\n      return {\n        position: \"absolute\",\n        cursor: \"s-resize\",\n        width: \"96%\",\n        bottom: 0,\n        left: \"50%\",\n        translate: \"-50% 50%\"\n      };\n    case \"w\":\n      return {\n        position: \"absolute\",\n        cursor: \"w-resize\",\n        height: \"96%\",\n        left: 0,\n        top: \"50%\",\n        translate: \"-50% -50%\"\n      };\n    case \"se\":\n      return {\n        position: \"absolute\",\n        cursor: \"se-resize\",\n        bottom: 0,\n        right: 0,\n        translate: \"50% 50%\"\n      };\n    case \"sw\":\n      return {\n        position: \"absolute\",\n        cursor: \"sw-resize\",\n        bottom: 0,\n        left: 0,\n        translate: \"-50% 50%\"\n      };\n    case \"ne\":\n      return {\n        position: \"absolute\",\n        cursor: \"ne-resize\",\n        top: 0,\n        right: 0,\n        translate: \"50% -50%\"\n      };\n    case \"nw\":\n      return {\n        position: \"absolute\",\n        cursor: \"nw-resize\",\n        top: 0,\n        left: 0,\n        translate: \"-50% -50%\"\n      };\n    default:\n      throw new Error(`Invalid handlePosition: ${handlePosition}`);\n  }\n}\n\n// src/image-cropper.dom.ts\nvar getRootId = (ctx) => ctx.ids?.root ?? `image-cropper:${ctx.id}`;\nvar getViewportId = (ctx) => ctx.ids?.viewport ?? `image-cropper:${ctx.id}:viewport`;\nvar getImageId = (ctx) => ctx.ids?.image ?? `image-cropper:${ctx.id}:image`;\nvar getSelectionId = (ctx) => ctx.ids?.selection ?? `image-cropper:${ctx.id}:selection`;\nvar getHandleId = (ctx, position) => ctx.ids?.handle?.(position) ?? `image-cropper:${ctx.id}:handle:${position}`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getViewportEl = (ctx) => ctx.getById(getViewportId(ctx));\nvar getImageEl = (ctx) => ctx.getById(getImageId(ctx));\nvar getSelectionEl = (ctx) => ctx.getById(getSelectionId(ctx));\nfunction drawCroppedImageToCanvas(params) {\n  const { context, scope } = params;\n  const imageEl = getImageEl(scope);\n  if (!imageEl || !imageEl.complete) return null;\n  const doc = imageEl.ownerDocument;\n  const crop = context.get(\"crop\");\n  const zoom = context.get(\"zoom\");\n  const rotation = context.get(\"rotation\");\n  const flip = context.get(\"flip\");\n  const viewportRect = context.get(\"viewportRect\");\n  const naturalSize = context.get(\"naturalSize\");\n  const offset = context.get(\"offset\");\n  const canvas = doc.createElement(\"canvas\");\n  canvas.width = crop.width;\n  canvas.height = crop.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return null;\n  ctx.save();\n  ctx.translate(canvas.width / 2, canvas.height / 2);\n  ctx.rotate(rotation * Math.PI / 180);\n  const scaleX = flip.horizontal ? -1 : 1;\n  const scaleY = flip.vertical ? -1 : 1;\n  ctx.scale(scaleX, scaleY);\n  const viewportCenterX = viewportRect.width / 2;\n  const viewportCenterY = viewportRect.height / 2;\n  const cropCenterX = crop.x + crop.width / 2;\n  const cropCenterY = crop.y + crop.height / 2;\n  const deltaX = cropCenterX - viewportCenterX;\n  const deltaY = cropCenterY - viewportCenterY;\n  const imageCenterX = naturalSize.width / 2;\n  const imageCenterY = naturalSize.height / 2;\n  const sourceX = imageCenterX + (deltaX - offset.x) / zoom;\n  const sourceY = imageCenterY + (deltaY - offset.y) / zoom;\n  const sourceWidth = crop.width / zoom;\n  const sourceHeight = crop.height / zoom;\n  ctx.drawImage(\n    imageEl,\n    sourceX - sourceWidth / 2,\n    sourceY - sourceHeight / 2,\n    sourceWidth,\n    sourceHeight,\n    -canvas.width / 2,\n    -canvas.height / 2,\n    canvas.width,\n    canvas.height\n  );\n  ctx.restore();\n  return canvas;\n}\nvar { min, max, abs, round, hypot, PI, cos, sin } = Math;\nvar isLeftHandle = (handlePosition) => handlePosition === \"w\" || handlePosition === \"nw\" || handlePosition === \"sw\";\nvar isRightHandle = (handlePosition) => handlePosition === \"e\" || handlePosition === \"ne\" || handlePosition === \"se\";\nvar isTopHandle = (handlePosition) => handlePosition === \"n\" || handlePosition === \"nw\" || handlePosition === \"ne\";\nvar isBottomHandle = (handlePosition) => handlePosition === \"s\" || handlePosition === \"sw\" || handlePosition === \"se\";\nvar isCornerHandle = (handlePosition) => (isLeftHandle(handlePosition) || isRightHandle(handlePosition)) && (isTopHandle(handlePosition) || isBottomHandle(handlePosition));\nvar isHorizontalEdgeHandle = (handlePosition) => (isLeftHandle(handlePosition) || isRightHandle(handlePosition)) && !(isTopHandle(handlePosition) || isBottomHandle(handlePosition));\nvar isVerticalEdgeHandle = (handlePosition) => (isTopHandle(handlePosition) || isBottomHandle(handlePosition)) && !(isLeftHandle(handlePosition) || isRightHandle(handlePosition));\nvar hasAspectRatio = (value) => typeof value === \"number\" && value > 0;\nvar resolveSizeLimits = (options) => {\n  const { minSize, maxSize, viewportSize, aspectRatio } = options;\n  let minWidth = min(minSize.width, viewportSize.width);\n  let minHeight = min(minSize.height, viewportSize.height);\n  let maxWidth = maxSize?.width ?? viewportSize.width;\n  if (!Number.isFinite(maxWidth)) maxWidth = viewportSize.width;\n  maxWidth = min(maxWidth, viewportSize.width);\n  let maxHeight = maxSize?.height ?? viewportSize.height;\n  if (!Number.isFinite(maxHeight)) maxHeight = viewportSize.height;\n  maxHeight = min(maxHeight, viewportSize.height);\n  maxWidth = max(minWidth, maxWidth);\n  maxHeight = max(minHeight, maxHeight);\n  const hasAspect = hasAspectRatio(aspectRatio);\n  if (hasAspect) {\n    const minWidthWithAspect = max(minWidth, minHeight * aspectRatio);\n    const minHeightWithAspect = minWidthWithAspect / aspectRatio;\n    minWidth = min(minWidthWithAspect, viewportSize.width);\n    minHeight = min(minHeightWithAspect, viewportSize.height);\n    let constrainedMaxWidth = min(maxWidth, maxHeight * aspectRatio, viewportSize.width);\n    let constrainedMaxHeight = constrainedMaxWidth / aspectRatio;\n    if (constrainedMaxHeight > maxHeight || constrainedMaxHeight > viewportSize.height) {\n      constrainedMaxHeight = min(maxHeight, viewportSize.height);\n      constrainedMaxWidth = constrainedMaxHeight * aspectRatio;\n    }\n    maxWidth = max(minWidth, min(constrainedMaxWidth, viewportSize.width));\n    maxHeight = max(minHeight, min(constrainedMaxHeight, viewportSize.height));\n  } else {\n    maxWidth = max(minWidth, min(maxWidth, viewportSize.width));\n    maxHeight = max(minHeight, min(maxHeight, viewportSize.height));\n  }\n  return { minWidth, minHeight, maxWidth, maxHeight, hasAspect };\n};\nvar clampAspectSize = (params) => {\n  const { widthValue, heightValue, limits, viewportRect, aspectRatio } = params;\n  const { minWidth, minHeight, maxWidth, maxHeight } = limits;\n  const constrainWidthFromHeight = (height) => {\n    let width = clampValue(height * aspectRatio, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    return { width, height: width / aspectRatio };\n  };\n  const clampByWidth = (value) => {\n    let width = clampValue(value, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    let height = width / aspectRatio;\n    if (height < minHeight) {\n      const constrained = constrainWidthFromHeight(minHeight);\n      width = constrained.width;\n      height = constrained.height;\n    }\n    if (height > maxHeight) {\n      const clampedHeight = min(maxHeight, viewportRect.height);\n      const constrained = constrainWidthFromHeight(clampedHeight);\n      width = constrained.width;\n      height = constrained.height;\n    }\n    if (height > viewportRect.height) {\n      const constrained = constrainWidthFromHeight(viewportRect.height);\n      width = constrained.width;\n      height = constrained.height;\n      if (height < minHeight) {\n        const reconstrainted = constrainWidthFromHeight(minHeight);\n        width = reconstrainted.width;\n        height = reconstrainted.height;\n      }\n    }\n    return { width, height };\n  };\n  const clampByHeight = (value) => {\n    let height = clampValue(value, minHeight, maxHeight);\n    height = min(height, viewportRect.height);\n    let width = height * aspectRatio;\n    width = clampValue(width, minWidth, maxWidth);\n    width = min(width, viewportRect.width);\n    let adjustedHeight = width / aspectRatio;\n    if (adjustedHeight < minHeight) {\n      const constrained = constrainWidthFromHeight(minHeight);\n      width = constrained.width;\n      adjustedHeight = constrained.height;\n    }\n    if (adjustedHeight > maxHeight) {\n      const clampedHeight = min(maxHeight, viewportRect.height);\n      const constrained = constrainWidthFromHeight(clampedHeight);\n      width = constrained.width;\n      adjustedHeight = constrained.height;\n    }\n    if (width > viewportRect.width) {\n      width = viewportRect.width;\n      adjustedHeight = width / aspectRatio;\n      if (adjustedHeight > maxHeight) {\n        const clampedHeight = min(maxHeight, viewportRect.height);\n        const constrained = constrainWidthFromHeight(clampedHeight);\n        width = constrained.width;\n        adjustedHeight = constrained.height;\n      }\n      if (adjustedHeight < minHeight) {\n        const constrained = constrainWidthFromHeight(minHeight);\n        width = constrained.width;\n        adjustedHeight = constrained.height;\n      }\n    }\n    return { width, height: adjustedHeight };\n  };\n  const byWidth = clampByWidth(widthValue);\n  const byHeight = clampByHeight(heightValue);\n  const deltaWidth = abs(byWidth.width - widthValue) + abs(byWidth.height - heightValue);\n  const deltaHeight = abs(byHeight.width - widthValue) + abs(byHeight.height - heightValue);\n  return deltaHeight < deltaWidth ? byHeight : byWidth;\n};\nvar applyDeltaToEdges = (params) => {\n  const { bounds, delta, handlePosition, viewportRect, minSize, maxSize } = params;\n  let { left, top, right, bottom } = bounds;\n  if (isLeftHandle(handlePosition)) {\n    const minLeft = max(0, right - maxSize.width);\n    const maxLeft = right - minSize.width;\n    left = clampValue(left + delta.x, minLeft, maxLeft);\n  }\n  if (isRightHandle(handlePosition)) {\n    const minRight = left + minSize.width;\n    const maxRight = min(viewportRect.width, left + maxSize.width);\n    right = clampValue(right + delta.x, minRight, maxRight);\n  }\n  if (isTopHandle(handlePosition)) {\n    const minTop = max(0, bottom - maxSize.height);\n    const maxTop = bottom - minSize.height;\n    top = clampValue(top + delta.y, minTop, maxTop);\n  }\n  if (isBottomHandle(handlePosition)) {\n    const minBottom = top + minSize.height;\n    const maxBottom = min(viewportRect.height, top + maxSize.height);\n    bottom = clampValue(bottom + delta.y, minBottom, maxBottom);\n  }\n  return { left, top, right, bottom };\n};\nvar applyAspectToHorizontalResize = (params) => {\n  const { bounds, limits, viewportRect, aspectRatio, handlePosition } = params;\n  const { left, top, right, bottom } = bounds;\n  const centerY = (top + bottom) / 2;\n  let nextWidth = right - left;\n  let nextHeight = nextWidth / aspectRatio;\n  const constrained = clampAspectSize({\n    widthValue: nextWidth,\n    heightValue: nextHeight,\n    limits,\n    viewportRect,\n    aspectRatio\n  });\n  nextWidth = constrained.width;\n  nextHeight = constrained.height;\n  const halfH = nextHeight / 2;\n  let newTop = centerY - halfH;\n  let newBottom = centerY + halfH;\n  if (newTop < 0) {\n    newTop = 0;\n    newBottom = nextHeight;\n  }\n  if (newBottom > viewportRect.height) {\n    newBottom = viewportRect.height;\n    newTop = newBottom - nextHeight;\n  }\n  return {\n    left: isRightHandle(handlePosition) ? left : right - nextWidth,\n    top: newTop,\n    right: isRightHandle(handlePosition) ? left + nextWidth : right,\n    bottom: newBottom\n  };\n};\nvar applyAspectToVerticalResize = (params) => {\n  const { bounds, limits, viewportRect, aspectRatio, handlePosition } = params;\n  const { left, top, right, bottom } = bounds;\n  const centerX = (left + right) / 2;\n  let nextHeight = bottom - top;\n  let nextWidth = nextHeight * aspectRatio;\n  const constrained = clampAspectSize({\n    widthValue: nextWidth,\n    heightValue: nextHeight,\n    limits,\n    viewportRect,\n    aspectRatio\n  });\n  nextWidth = constrained.width;\n  nextHeight = constrained.height;\n  const halfW = nextWidth / 2;\n  let newLeft = centerX - halfW;\n  let newRight = centerX + halfW;\n  if (newLeft < 0) {\n    newLeft = 0;\n    newRight = nextWidth;\n  }\n  if (newRight > viewportRect.width) {\n    newRight = viewportRect.width;\n    newLeft = newRight - nextWidth;\n  }\n  return {\n    left: newLeft,\n    top: isBottomHandle(handlePosition) ? top : bottom - nextHeight,\n    right: newRight,\n    bottom: isBottomHandle(handlePosition) ? top + nextHeight : bottom\n  };\n};\nvar applyCornerResize = (params) => {\n  const { bounds, width, height, handlePosition } = params;\n  const { left, top, right, bottom } = bounds;\n  if (isRightHandle(handlePosition) && isBottomHandle(handlePosition)) {\n    return { left, top, right: left + width, bottom: top + height };\n  } else if (isRightHandle(handlePosition) && isTopHandle(handlePosition)) {\n    return { left, top: bottom - height, right: left + width, bottom };\n  } else if (isBottomHandle(handlePosition)) {\n    return { left: right - width, top, right, bottom: top + height };\n  } else {\n    return { left: right - width, top: bottom - height, right, bottom };\n  }\n};\nfunction computeResizeCrop(options) {\n  const { cropStart, handlePosition, delta, viewportRect, minSize, maxSize, aspectRatio } = options;\n  let { x, y, width, height } = cropStart;\n  let left = x;\n  let top = y;\n  let right = x + width;\n  let bottom = y + height;\n  const { minWidth, minHeight, maxWidth, maxHeight, hasAspect } = resolveSizeLimits({\n    minSize,\n    maxSize,\n    viewportSize: viewportRect,\n    aspectRatio\n  });\n  const edgesAfterDelta = applyDeltaToEdges({\n    bounds: { left, top, right, bottom },\n    delta,\n    handlePosition,\n    viewportRect,\n    minSize,\n    maxSize\n  });\n  left = edgesAfterDelta.left;\n  top = edgesAfterDelta.top;\n  right = edgesAfterDelta.right;\n  bottom = edgesAfterDelta.bottom;\n  if (hasAspect) {\n    const limits = { minWidth, minHeight, maxWidth, maxHeight, hasAspect };\n    if (isCornerHandle(handlePosition)) {\n      let tempW = right - left;\n      let tempH = tempW / aspectRatio;\n      if (tempH > bottom - top || top + tempH > viewportRect.height || left + tempW > viewportRect.width) {\n        tempH = bottom - top;\n        tempW = tempH * aspectRatio;\n      }\n      const constrained = clampAspectSize({\n        widthValue: tempW,\n        heightValue: tempH,\n        limits,\n        viewportRect,\n        aspectRatio\n      });\n      const result = applyCornerResize({\n        bounds: { left, top, right, bottom },\n        width: constrained.width,\n        height: constrained.height,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    } else if (isHorizontalEdgeHandle(handlePosition)) {\n      const result = applyAspectToHorizontalResize({\n        bounds: { left, top, right, bottom },\n        limits,\n        viewportRect,\n        aspectRatio,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    } else if (isVerticalEdgeHandle(handlePosition)) {\n      const result = applyAspectToVerticalResize({\n        bounds: { left, top, right, bottom },\n        limits,\n        viewportRect,\n        aspectRatio,\n        handlePosition\n      });\n      left = result.left;\n      top = result.top;\n      right = result.right;\n      bottom = result.bottom;\n    }\n  }\n  const maxLeft = max(0, viewportRect.width - minWidth);\n  const maxTop = max(0, viewportRect.height - minHeight);\n  left = clampValue(left, 0, maxLeft);\n  top = clampValue(top, 0, maxTop);\n  const maxRight = min(viewportRect.width, left + maxWidth);\n  const maxBottom = min(viewportRect.height, top + maxHeight);\n  right = clampValue(right, left + minWidth, maxRight);\n  bottom = clampValue(bottom, top + minHeight, maxBottom);\n  return {\n    x: left,\n    y: top,\n    width: right - left,\n    height: bottom - top\n  };\n}\nfunction computeMoveCrop(cropStart, delta, viewportRect) {\n  return {\n    x: clampValue(cropStart.x + delta.x, 0, viewportRect.width - cropStart.width),\n    y: clampValue(cropStart.y + delta.y, 0, viewportRect.height - cropStart.height),\n    width: cropStart.width,\n    height: cropStart.height\n  };\n}\nfunction clampOffset(params) {\n  const { zoom, rotation, viewportSize, offset, fixedCropArea, crop, naturalSize } = params;\n  const { cos: cos2, sin: sin2 } = getRotationTransform(rotation);\n  if (fixedCropArea && crop && naturalSize) {\n    const aabb2 = computeAABB(naturalSize, zoom, cos2, sin2);\n    const center = getViewportCenter(viewportSize);\n    const cropRight = crop.x + crop.width;\n    const cropBottom = crop.y + crop.height;\n    const minPoint2 = {\n      x: cropRight - center.x - aabb2.width / 2,\n      y: cropBottom - center.y - aabb2.height / 2\n    };\n    const maxPoint2 = {\n      x: crop.x - center.x + aabb2.width / 2,\n      y: crop.y - center.y + aabb2.height / 2\n    };\n    return clampPoint(offset, minPoint2, maxPoint2);\n  }\n  const aabb = computeAABB(viewportSize, zoom, cos2, sin2);\n  const extraWidth = max(0, aabb.width - viewportSize.width);\n  const extraHeight = max(0, aabb.height - viewportSize.height);\n  const minPoint = { x: -extraWidth / 2, y: -extraHeight / 2 };\n  const maxPoint = { x: extraWidth / 2, y: extraHeight / 2 };\n  return clampPoint(offset, minPoint, maxPoint);\n}\nvar expandLeft = (crop, step, maxWidth) => {\n  const newX = max(0, crop.x - step);\n  const newWidth = crop.width + (crop.x - newX);\n  if (newWidth <= maxWidth) {\n    return { x: newX, width: newWidth };\n  }\n  return { x: crop.x + crop.width - maxWidth, width: maxWidth };\n};\nvar expandTop = (crop, step, maxHeight) => {\n  const newY = max(0, crop.y - step);\n  const newHeight = crop.height + (crop.y - newY);\n  if (newHeight <= maxHeight) {\n    return { y: newY, height: newHeight };\n  }\n  return { y: crop.y + crop.height - maxHeight, height: maxHeight };\n};\nvar shrinkFromLeft = (crop, step, minWidth) => {\n  const newX = min(crop.x + step, crop.x + crop.width - minWidth);\n  return { x: newX, width: crop.width - (newX - crop.x) };\n};\nvar shrinkFromTop = (crop, step, minHeight) => {\n  const newY = min(crop.y + step, crop.y + crop.height - minHeight);\n  return { y: newY, height: crop.height - (newY - crop.y) };\n};\nfunction computeKeyboardCrop(key, handlePosition, step, crop, viewportRect, minSize, maxSize) {\n  const nextCrop = { ...crop };\n  const { minWidth, minHeight, maxWidth, maxHeight } = resolveSizeLimits({\n    minSize,\n    maxSize,\n    viewportSize: viewportRect\n  });\n  const isCorner = isCornerHandle(handlePosition);\n  if (key === \"ArrowLeft\") {\n    if (isLeftHandle(handlePosition)) {\n      const expanded = expandLeft(crop, step, maxWidth);\n      nextCrop.x = expanded.x;\n      nextCrop.width = expanded.width;\n      if (isCorner && isTopHandle(handlePosition)) {\n        const expandedY = expandTop(crop, step, maxHeight);\n        nextCrop.y = expandedY.y;\n        nextCrop.height = expandedY.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        const newHeight = nextCrop.height + step;\n        nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      }\n    } else if (isRightHandle(handlePosition)) {\n      nextCrop.width = max(minWidth, nextCrop.width - step);\n      if (isCorner && isTopHandle(handlePosition)) {\n        const shrunk = shrinkFromTop(crop, step, minHeight);\n        nextCrop.y = shrunk.y;\n        nextCrop.height = shrunk.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        nextCrop.height = max(minHeight, nextCrop.height - step);\n      }\n    }\n  } else if (key === \"ArrowRight\") {\n    if (isLeftHandle(handlePosition)) {\n      const shrunk = shrinkFromLeft(crop, step, minWidth);\n      nextCrop.x = shrunk.x;\n      nextCrop.width = shrunk.width;\n      if (isCorner && isTopHandle(handlePosition)) {\n        const shrunkY = shrinkFromTop(crop, step, minHeight);\n        nextCrop.y = shrunkY.y;\n        nextCrop.height = shrunkY.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        nextCrop.height = max(minHeight, nextCrop.height - step);\n      }\n    } else if (isRightHandle(handlePosition)) {\n      const newWidth = nextCrop.width + step;\n      nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      if (isCorner && isTopHandle(handlePosition)) {\n        const expanded = expandTop(crop, step, maxHeight);\n        nextCrop.y = expanded.y;\n        nextCrop.height = expanded.height;\n      } else if (isCorner && isBottomHandle(handlePosition)) {\n        const newHeight = nextCrop.height + step;\n        nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      }\n    }\n  }\n  if (key === \"ArrowUp\") {\n    if (isTopHandle(handlePosition)) {\n      const expanded = expandTop(crop, step, maxHeight);\n      nextCrop.y = expanded.y;\n      nextCrop.height = expanded.height;\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const expandedX = expandLeft(crop, step, maxWidth);\n        nextCrop.x = expandedX.x;\n        nextCrop.width = expandedX.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        const newWidth = nextCrop.width + step;\n        nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      }\n    } else if (isBottomHandle(handlePosition)) {\n      nextCrop.height = max(minHeight, nextCrop.height - step);\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const shrunk = shrinkFromLeft(crop, step, minWidth);\n        nextCrop.x = shrunk.x;\n        nextCrop.width = shrunk.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        nextCrop.width = max(minWidth, nextCrop.width - step);\n      }\n    }\n  } else if (key === \"ArrowDown\") {\n    if (isTopHandle(handlePosition)) {\n      const shrunk = shrinkFromTop(crop, step, minHeight);\n      nextCrop.y = shrunk.y;\n      nextCrop.height = shrunk.height;\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const shrunkX = shrinkFromLeft(crop, step, minWidth);\n        nextCrop.x = shrunkX.x;\n        nextCrop.width = shrunkX.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        nextCrop.width = max(minWidth, nextCrop.width - step);\n      }\n    } else if (isBottomHandle(handlePosition)) {\n      const newHeight = nextCrop.height + step;\n      nextCrop.height = min(viewportRect.height - nextCrop.y, min(maxHeight, newHeight));\n      if (isCorner && isLeftHandle(handlePosition)) {\n        const expanded = expandLeft(crop, step, maxWidth);\n        nextCrop.x = expanded.x;\n        nextCrop.width = expanded.width;\n      } else if (isCorner && isRightHandle(handlePosition)) {\n        const newWidth = nextCrop.width + step;\n        nextCrop.width = min(viewportRect.width - nextCrop.x, min(maxWidth, newWidth));\n      }\n    }\n  }\n  return nextCrop;\n}\nfunction getKeyboardMoveDelta(key, step) {\n  switch (key) {\n    case \"ArrowLeft\":\n      return { x: -step, y: 0 };\n    case \"ArrowRight\":\n      return { x: step, y: 0 };\n    case \"ArrowUp\":\n      return { x: 0, y: -step };\n    case \"ArrowDown\":\n      return { x: 0, y: step };\n    default:\n      return ZERO_POINT;\n  }\n}\nvar resolveCropAspectRatio = (shape, aspectRatio) => shape === \"circle\" ? 1 : aspectRatio;\nvar getCropSizeLimits = (prop) => ({\n  minSize: { width: prop(\"minWidth\"), height: prop(\"minHeight\") },\n  maxSize: { width: prop(\"maxWidth\"), height: prop(\"maxHeight\") }\n});\nvar getNudgeStep = (prop, modifiers) => {\n  if (modifiers.ctrlKey || modifiers.metaKey) return prop(\"nudgeStepCtrl\");\n  if (modifiers.shiftKey) return prop(\"nudgeStepShift\");\n  return prop(\"nudgeStep\");\n};\nvar DEFAULT_VIEWPORT_FILL = 0.8;\nvar computeDefaultCropDimensions = (viewportRect, aspectRatio, fixedCropArea) => {\n  const targetWidth = viewportRect.width * DEFAULT_VIEWPORT_FILL;\n  const targetHeight = viewportRect.height * DEFAULT_VIEWPORT_FILL;\n  if (typeof aspectRatio === \"number\" && aspectRatio > 0) {\n    if (fixedCropArea) {\n      let height2 = viewportRect.height;\n      let width2 = height2 * aspectRatio;\n      if (width2 > viewportRect.width) {\n        width2 = viewportRect.width;\n        height2 = width2 / aspectRatio;\n      }\n      return { width: width2, height: height2 };\n    }\n    const targetAspect = targetWidth / targetHeight;\n    if (aspectRatio > targetAspect) {\n      const width2 = targetWidth;\n      const height2 = width2 / aspectRatio;\n      return { width: width2, height: height2 };\n    }\n    const height = targetHeight;\n    const width = height * aspectRatio;\n    return { width, height };\n  }\n  if (fixedCropArea) {\n    const size = min(viewportRect.width, viewportRect.height);\n    return { width: size, height: size };\n  }\n  return { width: targetWidth, height: targetHeight };\n};\nvar normalizeFlipState = (nextFlip, currentFlip) => {\n  if (!nextFlip) return currentFlip;\n  return {\n    horizontal: isBoolean(nextFlip.horizontal) ? nextFlip.horizontal : currentFlip.horizontal,\n    vertical: isBoolean(nextFlip.vertical) ? nextFlip.vertical : currentFlip.vertical\n  };\n};\nvar isEqualFlip = (a, b) => {\n  return a.horizontal === b.horizontal && a.vertical === b.vertical;\n};\nvar isVisibleRect = (rect) => rect.width > 0 && rect.height > 0;\nvar getCenterPoint = (rect) => ({\n  x: rect.x + rect.width / 2,\n  y: rect.y + rect.height / 2\n});\nvar getViewportCenter = (size) => ({\n  x: size.width / 2,\n  y: size.height / 2\n});\nvar centerRect = (size, viewport) => ({\n  x: max(0, (viewport.width - size.width) / 2),\n  y: max(0, (viewport.height - size.height) / 2)\n});\nvar getMidpoint = (p1, p2, offset = ZERO_POINT) => ({\n  x: (p1.x + p2.x) / 2 - offset.x,\n  y: (p1.y + p2.y) / 2 - offset.y\n});\nvar getMaxBounds = (cropSize, viewportSize) => ({\n  x: max(0, viewportSize.width - cropSize.width),\n  y: max(0, viewportSize.height - cropSize.height)\n});\nvar isSameSize = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar ZERO_POINT = { x: 0, y: 0 };\nvar getTouchDistance = (p1, p2) => {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  return hypot(dx, dy);\n};\nvar clampPoint = (point, min2, max2) => ({\n  x: clampValue(point.x, min2.x, max2.x),\n  y: clampValue(point.y, min2.y, max2.y)\n});\nvar subtractPoints = (a, b) => ({\n  x: a.x - b.x,\n  y: a.y - b.y\n});\nvar addPoints = (a, b) => ({\n  x: a.x + b.x,\n  y: a.y + b.y\n});\nvar roundRect = (rect) => ({\n  x: round(rect.x),\n  y: round(rect.y),\n  width: round(rect.width),\n  height: round(rect.height)\n});\nvar scaleRect = (rect, scale) => ({\n  x: rect.x * scale.x,\n  y: rect.y * scale.y,\n  width: rect.width * scale.x,\n  height: rect.height * scale.y\n});\nvar getRotationTransform = (rotation) => {\n  const theta = rotation % 360 * PI / 180;\n  return {\n    cos: abs(cos(theta)),\n    sin: abs(sin(theta))\n  };\n};\nvar computeAABB = (size, zoom, cos2, sin2) => {\n  const w = size.width * zoom;\n  const h = size.height * zoom;\n  return {\n    width: w * cos2 + h * sin2,\n    height: w * sin2 + h * cos2\n  };\n};\nvar scaleSize = (size, scale) => ({\n  width: size.width * scale,\n  height: size.height * scale\n});\n\n// src/image-cropper.connect.ts\nfunction connect(service, normalize) {\n  const { scope, send, context, prop, state, computed } = service;\n  const dragging = state.matches(\"dragging\");\n  const panning = state.matches(\"panning\");\n  const translations = prop(\"translations\");\n  const fixedCropArea = prop(\"fixedCropArea\");\n  const cropShape = prop(\"cropShape\");\n  const zoom = context.get(\"zoom\");\n  const rotation = context.get(\"rotation\");\n  const flip = context.get(\"flip\");\n  const crop = context.get(\"crop\");\n  const offset = context.get(\"offset\");\n  const naturalSize = context.get(\"naturalSize\");\n  const viewportRect = context.get(\"viewportRect\");\n  const isImageReady = computed(\"isImageReady\");\n  const isMeasured = computed(\"isMeasured\");\n  const roundedCrop = roundRect(crop);\n  const shouldIgnoreTouchPointer = (event) => {\n    if (event.pointerType !== \"touch\") return false;\n    const isSecondaryTouch = event.isPrimary === false;\n    const pinchActive = context.get(\"pinchDistance\") != null;\n    return isSecondaryTouch || pinchActive;\n  };\n  return {\n    zoom,\n    rotation,\n    flip,\n    crop,\n    offset,\n    naturalSize,\n    viewportRect,\n    dragging,\n    panning,\n    setZoom(value) {\n      send({ type: \"SET_ZOOM\", zoom: value });\n    },\n    zoomBy(delta) {\n      send({ type: \"SET_ZOOM\", zoom: zoom + delta });\n    },\n    setRotation(value) {\n      send({ type: \"SET_ROTATION\", rotation: value });\n    },\n    rotateBy(degrees) {\n      send({ type: \"SET_ROTATION\", rotation: rotation + degrees });\n    },\n    setFlip(nextFlip) {\n      if (!nextFlip) return;\n      const normalized = normalizeFlipState(nextFlip, flip);\n      if (isEqualFlip(normalized, flip)) return;\n      send({ type: \"SET_FLIP\", flip: normalized });\n    },\n    flipHorizontally(value) {\n      const nextValue = typeof value === \"boolean\" ? value : !flip.horizontal;\n      if (nextValue === flip.horizontal) return;\n      send({ type: \"SET_FLIP\", flip: { horizontal: nextValue } });\n    },\n    flipVertically(value) {\n      const nextValue = typeof value === \"boolean\" ? value : !flip.vertical;\n      if (nextValue === flip.vertical) return;\n      send({ type: \"SET_FLIP\", flip: { vertical: nextValue } });\n    },\n    resize(handlePosition, delta) {\n      if (!handlePosition) return;\n      if (fixedCropArea) return;\n      let deltaX = 0;\n      let deltaY = 0;\n      if (isLeftHandle(handlePosition)) {\n        deltaX = -delta;\n      } else if (isRightHandle(handlePosition)) {\n        deltaX = delta;\n      }\n      if (isTopHandle(handlePosition)) {\n        deltaY = -delta;\n      } else if (isBottomHandle(handlePosition)) {\n        deltaY = delta;\n      }\n      send({ type: \"RESIZE_CROP\", handlePosition, delta: { x: deltaX, y: deltaY } });\n    },\n    reset() {\n      send({ type: \"RESET\" });\n    },\n    getCropData() {\n      const scale = naturalSize.width / viewportRect.width;\n      const naturalX = (crop.x - offset.x) * scale;\n      const naturalY = (crop.y - offset.y) * scale;\n      const naturalWidth = crop.width * scale;\n      const naturalHeight = crop.height * scale;\n      return {\n        x: Math.round(naturalX),\n        y: Math.round(naturalY),\n        width: Math.round(naturalWidth),\n        height: Math.round(naturalHeight),\n        rotate: rotation,\n        flipX: flip.horizontal,\n        flipY: flip.vertical\n      };\n    },\n    async getCroppedImage(options = {}) {\n      const { type = \"image/png\", quality = 1, output = \"blob\" } = options;\n      if (!isVisibleRect(naturalSize)) return null;\n      const canvas = drawCroppedImageToCanvas(service);\n      if (!canvas) return null;\n      if (output === \"dataUrl\") {\n        return canvas.toDataURL(type, quality);\n      }\n      return new Promise((resolve) => {\n        canvas.toBlob(\n          (blob) => {\n            resolve(blob);\n          },\n          type,\n          quality\n        );\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"aria-roledescription\": translations.rootRoleDescription,\n        \"aria-label\": translations.rootLabel,\n        \"aria-description\": isImageReady ? translations.previewDescription({\n          crop: roundedCrop,\n          zoom: Number.isFinite(zoom) ? zoom : null,\n          rotation: Number.isFinite(rotation) ? rotation : null\n        }) : translations.previewLoading,\n        \"aria-live\": \"polite\",\n        \"aria-controls\": `${getViewportId(scope)} ${getSelectionId(scope)}`,\n        \"aria-busy\": isImageReady ? void 0 : \"true\",\n        \"data-fixed\": dataAttr(fixedCropArea),\n        \"data-shape\": cropShape,\n        \"data-pinch\": dataAttr(context.get(\"pinchDistance\") != null),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          \"--crop-width\": toPx(crop.width),\n          \"--crop-height\": toPx(crop.height),\n          \"--crop-x\": toPx(crop.x),\n          \"--crop-y\": toPx(crop.y),\n          \"--image-zoom\": zoom,\n          \"--image-rotation\": rotation,\n          \"--image-offset-x\": toPx(offset.x),\n          \"--image-offset-y\": toPx(offset.y)\n        }\n      });\n    },\n    getViewportProps() {\n      const viewportId = getViewportId(scope);\n      return normalize.element({\n        ...parts.viewport.attrs,\n        id: viewportId,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        \"data-disabled\": dataAttr(!!fixedCropArea),\n        style: {\n          position: \"relative\",\n          overflow: \"hidden\",\n          touchAction: \"none\",\n          userSelect: \"none\"\n        },\n        onPointerDown(event) {\n          if (event.pointerType === \"mouse\" && event.button !== 0) return;\n          if (shouldIgnoreTouchPointer(event)) return;\n          const target = getEventTarget(event);\n          const rootEl = getRootEl(scope);\n          if (!target || !rootEl || !contains(rootEl, target)) return;\n          const selectionEl = getSelectionEl(scope);\n          if (!fixedCropArea && contains(selectionEl, target)) return;\n          const handleEl = target.closest('[data-scope=\"image-cropper\"][data-part=\"handle\"]');\n          if (handleEl && contains(rootEl, handleEl)) return;\n          const point = getEventPoint(event);\n          send({ type: \"PAN_POINTER_DOWN\", point });\n        }\n      });\n    },\n    getImageProps() {\n      const flipHorizontal = flip.horizontal;\n      const flipVertical = flip.vertical;\n      const translate = `translate(${toPx(offset.x)}, ${toPx(offset.y)})`;\n      const rotate = `rotate(${rotation}deg)`;\n      const scaleX = zoom * (flipHorizontal ? -1 : 1);\n      const scaleY = zoom * (flipVertical ? -1 : 1);\n      const scale = `scale(${scaleX}, ${scaleY})`;\n      return normalize.element({\n        ...parts.image.attrs,\n        id: getImageId(scope),\n        draggable: false,\n        role: \"presentation\",\n        alt: \"\",\n        \"aria-hidden\": true,\n        \"data-ownedby\": getViewportId(scope),\n        \"data-ready\": dataAttr(isImageReady),\n        \"data-flip-horizontal\": dataAttr(flipHorizontal),\n        \"data-flip-vertical\": dataAttr(flipVertical),\n        onLoad(event) {\n          const imageEl = event.currentTarget;\n          if (!imageEl?.complete) return;\n          const { naturalWidth: width, naturalHeight: height } = imageEl;\n          send({ type: \"SET_NATURAL_SIZE\", src: \"element\", size: { width, height } });\n        },\n        style: {\n          pointerEvents: \"none\",\n          userSelect: \"none\",\n          transform: `${translate} ${rotate} ${scale}`,\n          willChange: \"transform\"\n        }\n      });\n    },\n    getSelectionProps() {\n      const disabled = !!fixedCropArea;\n      return normalize.element({\n        ...parts.selection.attrs,\n        id: getSelectionId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        role: \"slider\",\n        \"aria-label\": translations.selectionLabel({ shape: cropShape }),\n        \"aria-roledescription\": translations.selectionRoleDescription,\n        \"aria-disabled\": disabled ? \"true\" : void 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": isVisibleRect(viewportRect) ? Math.max(0, Math.round(viewportRect.width - crop.width)) : Math.max(roundedCrop.x, 0),\n        \"aria-valuenow\": roundedCrop.x,\n        \"aria-valuetext\": translations.selectionValueText({ shape: cropShape, ...roundedCrop }),\n        \"aria-description\": translations.selectionInstructions,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-shape\": cropShape,\n        \"data-measured\": dataAttr(isMeasured),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          position: \"absolute\",\n          top: \"var(--crop-y)\",\n          left: \"var(--crop-x)\",\n          width: \"var(--crop-width)\",\n          height: \"var(--crop-height)\",\n          touchAction: \"none\",\n          visibility: isMeasured ? void 0 : \"hidden\"\n        },\n        onPointerDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (shouldIgnoreTouchPointer(event)) return;\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", point });\n        },\n        onKeyDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (event.defaultPrevented) return;\n          const src = \"selection\";\n          const { shiftKey, ctrlKey, metaKey, altKey } = event;\n          const key = getEventKey(event, { dir: prop(\"dir\") });\n          const isZoomInKey = key === \"+\" || key === \"=\";\n          const isZoomOutKey = key === \"-\" || key === \"_\";\n          if (isZoomInKey || isZoomOutKey) {\n            const delta = isZoomInKey ? -1 : 1;\n            send({ type: \"ZOOM\", trigger: \"keyboard\", delta });\n            event.preventDefault();\n            return;\n          }\n          if (altKey && (key === \"ArrowUp\" || key === \"ArrowDown\" || key === \"ArrowLeft\" || key === \"ArrowRight\")) {\n            const handlePosition = key === \"ArrowUp\" || key === \"ArrowDown\" ? \"s\" : \"e\";\n            send({\n              type: \"NUDGE_RESIZE_CROP\",\n              handlePosition,\n              key,\n              src,\n              shiftKey,\n              ctrlKey,\n              metaKey\n            });\n            event.preventDefault();\n            return;\n          }\n          const keyMap = {\n            ArrowUp() {\n              send({ type: \"NUDGE_MOVE_CROP\", key: \"ArrowUp\", src, shiftKey, ctrlKey, metaKey });\n            },\n            ArrowDown() {\n              send({ type: \"NUDGE_MOVE_CROP\", key: \"ArrowDown\", src, shiftKey, ctrlKey, metaKey });\n            },\n            ArrowLeft() {\n              send({ type: \"NUDGE_MOVE_CROP\", key: \"ArrowLeft\", src, shiftKey, ctrlKey, metaKey });\n            },\n            ArrowRight() {\n              send({ type: \"NUDGE_MOVE_CROP\", key: \"ArrowRight\", src, shiftKey, ctrlKey, metaKey });\n            }\n          };\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getHandleProps(props2) {\n      const handlePosition = props2.position;\n      const disabled = !!fixedCropArea;\n      return normalize.element({\n        ...parts.handle.attrs,\n        id: getHandleId(scope, handlePosition),\n        \"data-position\": handlePosition,\n        \"aria-hidden\": \"true\",\n        role: \"presentation\",\n        \"data-disabled\": dataAttr(disabled),\n        style: getHandlePositionStyles(handlePosition),\n        onPointerDown(event) {\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          if (shouldIgnoreTouchPointer(event)) return;\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", point, handlePosition });\n        }\n      });\n    },\n    getGridProps(props2) {\n      const axis = props2.axis;\n      const isMeasured2 = computed(\"isMeasured\");\n      return normalize.element({\n        ...parts.grid.attrs,\n        \"aria-hidden\": \"true\",\n        \"data-axis\": axis,\n        \"data-dragging\": dataAttr(dragging),\n        \"data-panning\": dataAttr(panning),\n        style: {\n          position: \"absolute\",\n          inset: axis === \"horizontal\" ? \"33.33% 0\" : \"0 33.33%\",\n          pointerEvents: \"none\",\n          visibility: isMeasured2 ? void 0 : \"hidden\"\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    return {\n      minWidth: 40,\n      minHeight: 40,\n      maxWidth: Number.POSITIVE_INFINITY,\n      maxHeight: Number.POSITIVE_INFINITY,\n      defaultZoom: 1,\n      zoomStep: 0.1,\n      zoomSensitivity: 2,\n      minZoom: 1,\n      maxZoom: 5,\n      defaultRotation: 0,\n      defaultFlip: { horizontal: false, vertical: false },\n      fixedCropArea: false,\n      cropShape: \"rectangle\",\n      nudgeStep: 1,\n      nudgeStepShift: 10,\n      nudgeStepCtrl: 50,\n      ...props2,\n      translations: {\n        rootLabel: \"Image cropper\",\n        rootRoleDescription: \"Image cropper\",\n        previewLoading: \"Image cropper preview loading\",\n        previewDescription({ crop, zoom, rotation }) {\n          const zoomText = zoom != null && Number.isFinite(zoom) ? `${zoom.toFixed(2)}x zoom` : \"default zoom\";\n          const rotationText = rotation != null && Number.isFinite(rotation) ? `${Math.round(rotation)} degrees rotation` : \"0 degrees rotation\";\n          return `Image cropper preview, ${zoomText}, ${rotationText}. Crop positioned at ${crop.x}px from the left and ${crop.y}px from the top with a size of ${crop.width}px by ${crop.height}px.`;\n        },\n        selectionLabel: ({ shape }) => `Crop selection area (${shape === \"circle\" ? \"circle\" : \"rectangle\"})`,\n        selectionRoleDescription: \"2d slider\",\n        selectionInstructions: \"Use arrow keys to move the crop. Hold Alt with arrow keys to resize width or height. Press plus or minus to zoom.\",\n        selectionValueText({ shape, x, y, width, height }) {\n          if (shape === \"circle\") {\n            return `Position X ${x}px, Y ${y}px. Diameter ${width}px.`;\n          }\n          return `Position X ${x}px, Y ${y}px. Size ${width}px by ${height}px.`;\n        },\n        ...props2.translations\n      }\n    };\n  },\n  context({ bindable, prop }) {\n    return {\n      naturalSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      crop: bindable(() => ({\n        defaultValue: { x: 0, y: 0, width: 0, height: 0 },\n        onChange(crop) {\n          prop(\"onCropChange\")?.({ crop });\n        }\n      })),\n      pointerStart: bindable(() => ({\n        defaultValue: null\n      })),\n      cropStart: bindable(() => ({\n        defaultValue: null\n      })),\n      handlePosition: bindable(() => ({\n        defaultValue: null\n      })),\n      shiftLockRatio: bindable(() => ({\n        defaultValue: null\n      })),\n      pinchDistance: bindable(() => ({\n        defaultValue: null\n      })),\n      pinchMidpoint: bindable(() => ({\n        defaultValue: null\n      })),\n      zoom: bindable(() => ({\n        defaultValue: prop(\"zoom\") ?? prop(\"defaultZoom\"),\n        onChange(zoom) {\n          prop(\"onZoomChange\")?.({ zoom });\n        }\n      })),\n      rotation: bindable(() => ({\n        defaultValue: prop(\"defaultRotation\"),\n        value: prop(\"rotation\"),\n        onChange(rotation) {\n          prop(\"onRotationChange\")?.({ rotation });\n        }\n      })),\n      flip: bindable(() => {\n        const defaultFlip = prop(\"defaultFlip\");\n        return {\n          defaultValue: { ...defaultFlip },\n          value: prop(\"flip\"),\n          onChange(flip) {\n            prop(\"onFlipChange\")?.({ flip });\n          }\n        };\n      }),\n      offset: bindable(() => ({\n        defaultValue: ZERO_POINT\n      })),\n      offsetStart: bindable(() => ({\n        defaultValue: null\n      })),\n      viewportRect: bindable(() => ({\n        defaultValue: { width: 0, height: 0, top: 0, left: 0, right: 0, bottom: 0 }\n      }))\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  on: {\n    PINCH_START: {\n      actions: [\"setPinchDistance\"]\n    },\n    PINCH_MOVE: {\n      actions: [\"handlePinchMove\"]\n    },\n    PINCH_END: {\n      actions: [\"clearPinchDistance\"]\n    },\n    SET_ZOOM: {\n      actions: [\"updateZoom\"]\n    },\n    SET_ROTATION: {\n      actions: [\"setRotation\"]\n    },\n    SET_FLIP: {\n      actions: [\"setFlip\"]\n    },\n    RESIZE_CROP: {\n      guard: \"canResizeCrop\",\n      actions: [\"resizeCrop\"]\n    },\n    VIEWPORT_RESIZE: {\n      actions: [\"resizeViewport\"]\n    },\n    RESET: {\n      actions: [\"resetToInitialState\"]\n    }\n  },\n  computed: {\n    isMeasured: ({ context }) => isVisibleRect(context.get(\"viewportRect\")) && isVisibleRect(context.get(\"crop\")),\n    isImageReady: ({ context }) => isVisibleRect(context.get(\"naturalSize\"))\n  },\n  watch({ track, context, prop, send }) {\n    track([() => prop(\"zoom\")], () => {\n      const propZoom = prop(\"zoom\");\n      if (propZoom === void 0) return;\n      const currentZoom = context.get(\"zoom\");\n      if (propZoom === currentZoom) return;\n      send({ type: \"SET_ZOOM\", zoom: propZoom, src: \"prop\" });\n    });\n  },\n  states: {\n    idle: {\n      entry: [\"checkImageStatus\"],\n      effects: [\"trackViewportResize\", \"trackWheelEvent\", \"trackTouchEvents\"],\n      on: {\n        SET_NATURAL_SIZE: {\n          actions: [\"setNaturalSize\"]\n        },\n        SET_DEFAULT_CROP: {\n          actions: [\"setDefaultCrop\"]\n        },\n        POINTER_DOWN: {\n          guard: \"canDragSelection\",\n          target: \"dragging\",\n          actions: [\"setPointerStart\", \"setCropStart\", \"setHandlePosition\"]\n        },\n        PAN_POINTER_DOWN: {\n          guard: \"canPan\",\n          target: \"panning\",\n          actions: [\"setPointerStart\", \"setOffsetStart\"]\n        },\n        ZOOM: {\n          guard: \"hasViewportRect\",\n          actions: [\"updateZoom\"]\n        },\n        NUDGE_RESIZE_CROP: {\n          guard: \"hasViewportRect\",\n          actions: [\"nudgeResizeCrop\"]\n        },\n        NUDGE_MOVE_CROP: {\n          guard: \"hasViewportRect\",\n          actions: [\"nudgeMoveCrop\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"updateCrop\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\n            \"clearPointerStart\",\n            \"clearCropStart\",\n            \"clearHandlePosition\",\n            \"clearOffsetStart\",\n            \"clearShiftRatio\"\n          ]\n        }\n      }\n    },\n    panning: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"updatePanOffset\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"clearPointerStart\", \"clearOffsetStart\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      hasViewportRect({ context }) {\n        return isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canResizeCrop({ context, prop }) {\n        return !prop(\"fixedCropArea\") && isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canPan({ context }) {\n        return isVisibleRect(context.get(\"naturalSize\")) && isVisibleRect(context.get(\"viewportRect\"));\n      },\n      canDragSelection({ context, prop }) {\n        return isVisibleRect(context.get(\"viewportRect\")) && !prop(\"fixedCropArea\");\n      }\n    },\n    actions: {\n      checkImageStatus({ send, scope, context }) {\n        const naturalSize = context.get(\"naturalSize\");\n        const imageEl = getImageEl(scope);\n        if (!imageEl?.complete) return;\n        const { naturalWidth: width, naturalHeight: height } = imageEl;\n        if (isVisibleRect({ width, height }) && !isVisibleRect(naturalSize)) {\n          send({ type: \"SET_NATURAL_SIZE\", src: \"ssr\", size: { width, height } });\n        }\n      },\n      setNaturalSize({ event, context, send }) {\n        context.set(\"naturalSize\", event.size);\n        send({ type: \"SET_DEFAULT_CROP\", src: \"init\" });\n      },\n      setDefaultCrop({ context, prop, scope }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const viewportRect = getBoundingRect(viewportEl);\n        if (!isVisibleRect(viewportRect)) return;\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const { minSize, maxSize } = getCropSizeLimits(prop);\n        const clampSize = (rect) => {\n          const result = computeResizeCrop({\n            cropStart: rect,\n            handlePosition: \"se\",\n            delta: ZERO_POINT,\n            viewportRect,\n            minSize,\n            maxSize,\n            aspectRatio\n          });\n          return { width: result.width, height: result.height };\n        };\n        const initialCrop = prop(\"initialCrop\");\n        if (initialCrop) {\n          const constrainedSize2 = clampSize({\n            x: 0,\n            y: 0,\n            width: initialCrop.width,\n            height: initialCrop.height\n          });\n          const { width: width2, height: height2 } = constrainedSize2;\n          const max2 = getMaxBounds({ width: width2, height: height2 }, viewportRect);\n          const { x: x2, y: y2 } = clampPoint(initialCrop, ZERO_POINT, max2);\n          context.set(\"crop\", { x: x2, y: y2, width: width2, height: height2 });\n          return;\n        }\n        const fixedCropArea = prop(\"fixedCropArea\");\n        const defaultSize = computeDefaultCropDimensions(viewportRect, aspectRatio, fixedCropArea);\n        const constrainedSize = clampSize({\n          x: 0,\n          y: 0,\n          width: defaultSize.width,\n          height: defaultSize.height\n        });\n        const width = constrainedSize.width;\n        const height = constrainedSize.height;\n        const { x, y } = centerRect({ width, height }, viewportRect);\n        context.set(\"crop\", { x, y, width, height });\n        context.set(\"viewportRect\", viewportRect);\n      },\n      setPointerStart({ event, context }) {\n        const point = event.point;\n        if (!point) return;\n        context.set(\"pointerStart\", point);\n      },\n      setOffsetStart({ context }) {\n        const offset = context.get(\"offset\");\n        context.set(\"offsetStart\", { ...offset });\n      },\n      setCropStart({ context }) {\n        const crop = context.get(\"crop\");\n        context.set(\"cropStart\", crop);\n      },\n      updateCrop({ context, event, prop }) {\n        const handlePosition = context.get(\"handlePosition\");\n        const pointerStart = context.get(\"pointerStart\");\n        const cropStart = context.get(\"cropStart\");\n        const viewportRect = context.get(\"viewportRect\");\n        const cropShape = prop(\"cropShape\");\n        const aspectRatioProp = prop(\"aspectRatio\");\n        let aspectRatio = resolveCropAspectRatio(cropShape, aspectRatioProp);\n        const { minSize, maxSize } = getCropSizeLimits(prop);\n        if (!pointerStart || !cropStart) return;\n        const currentPoint = event.point;\n        const delta = subtractPoints(currentPoint, pointerStart);\n        let nextCrop;\n        if (handlePosition) {\n          const allowShiftLock = typeof aspectRatioProp === \"undefined\" && cropShape !== \"circle\";\n          if (allowShiftLock) {\n            if (event.shiftKey) {\n              const currentCrop = context.get(\"crop\");\n              const w = currentCrop.width;\n              const h = currentCrop.height;\n              if (w > 0 && h > 0) {\n                const ratio = w / h;\n                if (ratio > 0) context.set(\"shiftLockRatio\", ratio);\n              }\n              const lockRatio = context.get(\"shiftLockRatio\");\n              if (lockRatio !== null && lockRatio > 0) aspectRatio = lockRatio;\n            } else {\n              context.set(\"shiftLockRatio\", null);\n            }\n          } else {\n            context.set(\"shiftLockRatio\", null);\n          }\n          nextCrop = computeResizeCrop({\n            cropStart,\n            handlePosition,\n            delta,\n            viewportRect,\n            minSize,\n            maxSize,\n            aspectRatio\n          });\n        } else {\n          nextCrop = computeMoveCrop(cropStart, delta, viewportRect);\n        }\n        context.set(\"crop\", nextCrop);\n      },\n      updatePanOffset({ context, event, prop }) {\n        const point = event.point;\n        const pointerStart = context.get(\"pointerStart\");\n        const offsetStart = context.get(\"offsetStart\");\n        if (!point || !pointerStart || !offsetStart) return;\n        const zoom = context.get(\"zoom\");\n        const rotation = context.get(\"rotation\");\n        const viewportRect = context.get(\"viewportRect\");\n        const delta = subtractPoints(point, pointerStart);\n        const nextOffset = clampOffset({\n          zoom,\n          rotation,\n          viewportSize: viewportRect,\n          offset: addPoints(offsetStart, delta),\n          fixedCropArea: prop(\"fixedCropArea\"),\n          crop: context.get(\"crop\"),\n          naturalSize: context.get(\"naturalSize\")\n        });\n        context.set(\"offset\", nextOffset);\n      },\n      setHandlePosition({ event, context }) {\n        const position = event.handlePosition;\n        if (!position) return;\n        context.set(\"handlePosition\", position);\n      },\n      setRotation({ context, event }) {\n        const rotation = event.rotation;\n        const nextRotation = clampValue(rotation, 0, 360);\n        context.set(\"rotation\", nextRotation);\n      },\n      setFlip({ context, event }) {\n        const nextFlip = event.flip;\n        if (!nextFlip) return;\n        const currentFlip = context.get(\"flip\");\n        const normalized = normalizeFlipState(nextFlip, currentFlip);\n        if (isEqualFlip(normalized, currentFlip)) return;\n        context.set(\"flip\", normalized);\n      },\n      resizeCrop({ context, event, prop }) {\n        const { handlePosition, delta } = event;\n        if (!handlePosition) return;\n        const viewportRect = context.get(\"viewportRect\");\n        if (!isVisibleRect(viewportRect)) return;\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const { minSize, maxSize } = getCropSizeLimits(prop);\n        const crop = context.get(\"crop\");\n        const nextCrop = computeResizeCrop({\n          cropStart: crop,\n          handlePosition,\n          delta,\n          viewportRect,\n          minSize,\n          maxSize,\n          aspectRatio\n        });\n        context.set(\"crop\", nextCrop);\n      },\n      clearPointerStart({ context }) {\n        context.set(\"pointerStart\", null);\n      },\n      clearCropStart({ context }) {\n        context.set(\"cropStart\", null);\n      },\n      clearHandlePosition({ context }) {\n        context.set(\"handlePosition\", null);\n      },\n      clearOffsetStart({ context }) {\n        context.set(\"offsetStart\", null);\n      },\n      clearShiftRatio({ context }) {\n        context.set(\"shiftLockRatio\", null);\n      },\n      updateZoom({ context, event, prop }) {\n        let { delta, point, zoom: targetZoom, scale, panDelta } = event;\n        const crop = context.get(\"crop\");\n        const currentZoom = context.get(\"zoom\");\n        const currentOffset = context.get(\"offset\");\n        const rotation = context.get(\"rotation\");\n        const viewportRect = context.get(\"viewportRect\");\n        const naturalSize = context.get(\"naturalSize\");\n        const fixedCropArea = prop(\"fixedCropArea\");\n        if (!point) {\n          point = getCenterPoint(crop);\n        }\n        const step = Math.abs(prop(\"zoomStep\"));\n        const sensitivity = Math.max(0, prop(\"zoomSensitivity\"));\n        const [minZoom, maxZoom] = [prop(\"minZoom\"), prop(\"maxZoom\")];\n        const calculateNextZoom = () => {\n          if (typeof targetZoom === \"number\") {\n            return clampValue(targetZoom, minZoom, maxZoom);\n          }\n          if (event.trigger === \"touch\" && typeof scale === \"number\") {\n            const minScale = 0.5;\n            const maxScale = 2;\n            const clampedScale = clampValue(scale, minScale, maxScale);\n            const smoothing = sensitivity > 0 ? Math.pow(clampedScale, sensitivity) : clampedScale;\n            return clampValue(currentZoom * smoothing, minZoom, maxZoom);\n          }\n          if (typeof delta === \"number\") {\n            const direction = Math.sign(delta) < 0 ? 1 : -1;\n            return clampValue(currentZoom + step * direction, minZoom, maxZoom);\n          }\n          return null;\n        };\n        const applyClampedOffset = (zoom, offset) => {\n          return clampOffset({\n            zoom,\n            rotation,\n            viewportSize: viewportRect,\n            offset,\n            fixedCropArea,\n            crop,\n            naturalSize\n          });\n        };\n        const nextZoom = calculateNextZoom();\n        if (nextZoom === null) return;\n        if (nextZoom === currentZoom && panDelta) {\n          const nextOffset2 = applyClampedOffset(currentZoom, addPoints(currentOffset, panDelta));\n          context.set(\"offset\", nextOffset2);\n          return;\n        }\n        if (nextZoom === currentZoom) return;\n        const { width: viewportWidth, height: viewportHeight } = viewportRect;\n        const { x: centerX, y: centerY } = getViewportCenter(viewportRect);\n        const zoomRatio = nextZoom / currentZoom;\n        let nextOffset = {\n          x: (1 - zoomRatio) * (point.x - centerX) + zoomRatio * currentOffset.x,\n          y: (1 - zoomRatio) * (point.y - centerY) + zoomRatio * currentOffset.y\n        };\n        if (panDelta) {\n          nextOffset = applyClampedOffset(nextZoom, addPoints(nextOffset, panDelta));\n        } else if (nextZoom < currentZoom) {\n          if (fixedCropArea) {\n            nextOffset = applyClampedOffset(nextZoom, nextOffset);\n          } else {\n            const { width: scaledImageWidth, height: scaledImageHeight } = scaleSize(viewportRect, nextZoom);\n            if (scaledImageWidth <= viewportWidth) {\n              nextOffset.x = 0;\n            } else {\n              const minX = viewportWidth - centerX - scaledImageWidth / 2;\n              const maxX = scaledImageWidth / 2 - centerX;\n              nextOffset.x = Math.max(minX, Math.min(maxX, nextOffset.x));\n            }\n            if (scaledImageHeight <= viewportHeight) {\n              nextOffset.y = 0;\n            } else {\n              const minY = viewportHeight - centerY - scaledImageHeight / 2;\n              const maxY = scaledImageHeight / 2 - centerY;\n              nextOffset.y = Math.max(minY, Math.min(maxY, nextOffset.y));\n            }\n          }\n        }\n        context.set(\"zoom\", nextZoom);\n        context.set(\"offset\", nextOffset);\n      },\n      setPinchDistance({ context, event, send }) {\n        const touches = Array.isArray(event.touches) ? event.touches : [];\n        if (touches.length < 2) return;\n        if (context.get(\"pointerStart\") !== null) {\n          send({ type: \"POINTER_UP\", src: \"pinch\" });\n        }\n        const [first, second] = touches;\n        const distance = getTouchDistance(first, second);\n        const viewportRect = context.get(\"viewportRect\");\n        const midpoint = getMidpoint(first, second, { x: viewportRect.left, y: viewportRect.top });\n        context.set(\"pinchDistance\", distance);\n        context.set(\"pinchMidpoint\", midpoint);\n      },\n      handlePinchMove({ context, event, send }) {\n        const touches = Array.isArray(event.touches) ? event.touches : [];\n        if (touches.length < 2) return;\n        const [first, second] = touches;\n        const distance = getTouchDistance(first, second);\n        const lastDistance = context.get(\"pinchDistance\");\n        const lastMidpoint = context.get(\"pinchMidpoint\");\n        const viewportRect = context.get(\"viewportRect\");\n        const midpoint = getMidpoint(first, second, { x: viewportRect.left, y: viewportRect.top });\n        if (lastDistance != null && lastDistance > 0 && lastMidpoint != null) {\n          const delta = lastDistance - distance;\n          const scale = distance / lastDistance;\n          const distanceChange = Math.abs(delta);\n          const hasSignificantZoom = distanceChange > 1;\n          const panDelta = subtractPoints(midpoint, lastMidpoint);\n          send({\n            type: \"ZOOM\",\n            trigger: \"touch\",\n            delta,\n            scale: hasSignificantZoom ? scale : 1,\n            point: midpoint,\n            panDelta\n          });\n        }\n        context.set(\"pinchDistance\", distance);\n        context.set(\"pinchMidpoint\", midpoint);\n      },\n      clearPinchDistance({ context }) {\n        context.set(\"pinchDistance\", null);\n        context.set(\"pinchMidpoint\", null);\n      },\n      nudgeResizeCrop({ context, event, prop }) {\n        const { key, handlePosition, shiftKey, ctrlKey, metaKey } = event;\n        const crop = context.get(\"crop\");\n        const viewportRect = context.get(\"viewportRect\");\n        const step = getNudgeStep(prop, { shiftKey, ctrlKey, metaKey });\n        const { minSize, maxSize } = getCropSizeLimits(prop);\n        const nextCrop = computeKeyboardCrop(key, handlePosition, step, crop, viewportRect, minSize, maxSize);\n        context.set(\"crop\", nextCrop);\n      },\n      nudgeMoveCrop({ context, event, prop }) {\n        const { key, shiftKey, ctrlKey, metaKey } = event;\n        const crop = context.get(\"crop\");\n        const viewportRect = context.get(\"viewportRect\");\n        const step = getNudgeStep(prop, { shiftKey, ctrlKey, metaKey });\n        const delta = getKeyboardMoveDelta(key, step);\n        const nextCrop = computeMoveCrop(crop, delta, viewportRect);\n        context.set(\"crop\", nextCrop);\n      },\n      resizeViewport({ context, prop, scope, send }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const newViewportRect = getBoundingRect(viewportEl);\n        if (!isVisibleRect(newViewportRect)) return;\n        const oldViewportRect = context.get(\"viewportRect\");\n        if (isSameSize(oldViewportRect, newViewportRect)) {\n          return;\n        }\n        context.set(\"viewportRect\", newViewportRect);\n        const oldCrop = context.get(\"crop\");\n        if (!isVisibleRect(oldViewportRect)) {\n          if (!isVisibleRect(oldCrop)) {\n            send({ type: \"SET_DEFAULT_CROP\", src: \"viewport-resize\" });\n            return;\n          }\n        }\n        const cropShape = prop(\"cropShape\");\n        const aspectRatio = resolveCropAspectRatio(cropShape, prop(\"aspectRatio\"));\n        const { minSize, maxSize } = getCropSizeLimits(prop);\n        const scale = {\n          x: newViewportRect.width / oldViewportRect.width,\n          y: newViewportRect.height / oldViewportRect.height\n        };\n        let newCrop = scaleRect(oldCrop, scale);\n        const constrainedCrop = computeResizeCrop({\n          cropStart: newCrop,\n          handlePosition: \"se\",\n          delta: ZERO_POINT,\n          viewportRect: newViewportRect,\n          minSize,\n          maxSize,\n          aspectRatio\n        });\n        const max2 = getMaxBounds(constrainedCrop, newViewportRect);\n        const { x, y } = clampPoint(constrainedCrop, ZERO_POINT, max2);\n        context.set(\"crop\", {\n          x,\n          y,\n          width: constrainedCrop.width,\n          height: constrainedCrop.height\n        });\n      },\n      resetToInitialState({ context }) {\n        context.set(\"zoom\", context.initial(\"zoom\"));\n        context.set(\"rotation\", context.initial(\"rotation\"));\n        context.set(\"flip\", context.initial(\"flip\"));\n        context.set(\"offset\", ZERO_POINT);\n        context.set(\"crop\", context.initial(\"crop\"));\n      }\n    },\n    effects: {\n      trackPointerMove({ scope, send }) {\n        function onPointerMove(event) {\n          const point = getEventPoint(event);\n          const target = getEventTarget(event);\n          send({ type: \"POINTER_MOVE\", point, target, shiftKey: event.shiftKey });\n        }\n        function onPointerUp() {\n          send({ type: \"POINTER_UP\" });\n        }\n        return callAll(\n          addDomEvent(scope.getDoc(), \"pointermove\", onPointerMove),\n          addDomEvent(scope.getDoc(), \"pointerup\", onPointerUp)\n        );\n      },\n      trackViewportResize({ scope, send }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        return resizeObserverBorderBox.observe(viewportEl, () => {\n          send({ type: \"VIEWPORT_RESIZE\", src: \"resize\" });\n        });\n      },\n      trackWheelEvent({ scope, send }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        function onWheel(event) {\n          event.preventDefault();\n          if (!viewportEl) return;\n          const rect = viewportEl.getBoundingClientRect();\n          const point = {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top\n          };\n          send({ type: \"ZOOM\", trigger: \"wheel\", delta: event.deltaY, point });\n        }\n        return addDomEvent(viewportEl, \"wheel\", onWheel, { passive: false });\n      },\n      trackTouchEvents({ scope, send }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        function onTouchStart(event) {\n          if (event.touches.length >= 2) {\n            event.preventDefault();\n            const touches = Array.from(event.touches).map((touch) => ({\n              x: touch.clientX,\n              y: touch.clientY\n            }));\n            send({ type: \"PINCH_START\", touches });\n          }\n        }\n        function onTouchMove(event) {\n          if (event.touches.length >= 2) {\n            event.preventDefault();\n            const touches = Array.from(event.touches).map((touch) => ({\n              x: touch.clientX,\n              y: touch.clientY\n            }));\n            send({ type: \"PINCH_MOVE\", touches });\n          }\n        }\n        function onTouchEnd(event) {\n          if (event.touches.length < 2) {\n            send({ type: \"PINCH_END\" });\n          }\n        }\n        return callAll(\n          addDomEvent(viewportEl, \"touchstart\", onTouchStart, { passive: false }),\n          addDomEvent(viewportEl, \"touchmove\", onTouchMove, { passive: false }),\n          addDomEvent(viewportEl, \"touchend\", onTouchEnd)\n        );\n      }\n    }\n  }\n});\nvar getBoundingRect = (el) => {\n  const rect = el.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  };\n};\nvar props = createProps()([\n  \"id\",\n  \"ids\",\n  \"dir\",\n  \"getRootNode\",\n  \"initialCrop\",\n  \"minWidth\",\n  \"minHeight\",\n  \"maxWidth\",\n  \"maxHeight\",\n  \"aspectRatio\",\n  \"cropShape\",\n  \"zoom\",\n  \"rotation\",\n  \"flip\",\n  \"defaultZoom\",\n  \"defaultRotation\",\n  \"defaultFlip\",\n  \"zoomStep\",\n  \"zoomSensitivity\",\n  \"minZoom\",\n  \"maxZoom\",\n  \"onZoomChange\",\n  \"onRotationChange\",\n  \"onFlipChange\",\n  \"onCropChange\",\n  \"fixedCropArea\",\n  \"nudgeStep\",\n  \"nudgeStepShift\",\n  \"nudgeStepCtrl\",\n  \"translations\"\n]);\nvar splitProps = createSplitProps(props);\nvar handles = [\"nw\", \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\"];\n\nexport { anatomy, connect, handles, machine, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}