{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine, memo } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\"root\", \"area\", \"control\", \"item\", \"itemValue\", \"itemLabel\", \"actionTrigger\", \"separator\");\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = ctx => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    computed,\n    scope\n  } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({\n        type: \"START\"\n      });\n    },\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    reset() {\n      send({\n        type: \"RESET\"\n      });\n    },\n    restart() {\n      send({\n        type: \"RESTART\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(`[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`);\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: props2.action.toUpperCase()\n          });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    validateProps(props2);\n    return {\n      interval: 1e3,\n      startMs: 0,\n      ...props2\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\")\n      }))\n    };\n  },\n  watch({\n    track,\n    send,\n    prop\n  }) {\n    track([() => prop(\"startMs\")], () => {\n      send({\n        type: \"RESTART\"\n      });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({\n      context\n    }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({\n      computed\n    }) => formatTime(computed(\"time\")),\n    progressPercent: memo(({\n      context,\n      prop\n    }) => [context.get(\"currentMs\"), prop(\"targetMs\"), prop(\"startMs\"), prop(\"countdown\")], ([currentMs, targetMs = 0, startMs, countdown]) => {\n      const percent = countdown ? toPercent(currentMs, targetMs, startMs) : toPercent(currentMs, startMs, targetMs);\n      return clampValue(percent, 0, 1);\n    })\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [{\n          target: \"idle\",\n          guard: \"hasReachedTarget\",\n          actions: [\"invokeOnComplete\"]\n        }, {\n          actions: [\"updateTime\", \"invokeOnTick\"]\n        }],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({\n        prop,\n        send\n      }) {\n        return setRafInterval(({\n          deltaMs\n        }) => {\n          send({\n            type: \"TICK\",\n            deltaMs\n          });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"CONTINUE\"\n          });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({\n        context,\n        prop,\n        event\n      }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", prev => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime({\n        context,\n        prop\n      }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({\n        context,\n        prop,\n        computed\n      }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({\n        prop\n      }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({\n        context,\n        prop\n      }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const {\n    startMs,\n    targetMs,\n    countdown,\n    interval\n  } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(`[timer] Invalid interval: ${interval}. Must be a positive number.`);\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(`[timer] Invalid startMs: ${startMs}. Must be a non-negative number.`);\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(`[timer] Invalid targetMs: ${targetMs}. Must be a non-negative number.`);\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(`[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than targetMs (${targetMs}).`);\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(`[timer] Invalid stopwatch configuration: startMs (${startMs}) must be less than targetMs (${targetMs}).`);\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(`[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than 0 when no targetMs is provided.`);\n  }\n}\nvar segments = /* @__PURE__ */new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some(key => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const {\n      days = 0,\n      hours = 0,\n      minutes = 0,\n      seconds = 0,\n      milliseconds = 0\n    } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\"autoStart\", \"countdown\", \"getRootNode\", \"id\", \"ids\", \"interval\", \"onComplete\", \"onTick\", \"startMs\", \"targetMs\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":{"version":3,"names":["createAnatomy","setRafTimeout","setRafInterval","clampValue","createSplitProps","match","isObject","createMachine","memo","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getAreaId","area","validActions","Set","connect","service","normalize","state","send","computed","scope","running","matches","paused","time","formattedTime","progressPercent","start","type","pause","resume","reset","restart","getRootProps","element","attrs","getAreaProps","role","days","hours","minutes","seconds","getControlProps","control","getItemProps","props2","value","item","style","getItemLabelProps","itemLabel","getItemValueProps","itemValue","getSeparatorProps","separator","getActionTriggerProps","has","action","Error","Array","from","join","button","actionTrigger","hidden","onClick","event","defaultPrevented","toUpperCase","machine","props","validateProps","interval","startMs","initialState","prop","context","bindable","currentMs","defaultValue","watch","track","on","RESTART","target","actions","msToTime","get","formatTime","targetMs","countdown","percent","toPercent","states","idle","START","RESET","effects","CONTINUE","PAUSE","TICK","guard","RESUME","implementations","keepTicking","deltaMs","waitForNextTick","updateTime","sign","roundToInterval","set","prev","newValue","Math","max","min","resetTime","invokeOnTick","invokeOnComplete","guards","hasReachedTarget","ms","milliseconds","floor","minValue","maxValue","range","padStart","num","size","toString","segments","isTimeSegment","date","Object","keys","some","key","parse","Date","getTime","splitProps"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@zag-js/timer/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine, memo } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\n  \"root\",\n  \"area\",\n  \"control\",\n  \"item\",\n  \"itemValue\",\n  \"itemLabel\",\n  \"actionTrigger\",\n  \"separator\"\n);\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = (ctx) => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = (ctx) => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */ new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const { state, send, computed, scope } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({ type: \"START\" });\n    },\n    pause() {\n      send({ type: \"PAUSE\" });\n    },\n    resume() {\n      send({ type: \"RESUME\" });\n    },\n    reset() {\n      send({ type: \"RESET\" });\n    },\n    restart() {\n      send({ type: \"RESTART\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(\n          `[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`\n        );\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: props2.action.toUpperCase() });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    validateProps(props2);\n    return {\n      interval: 1e3,\n      startMs: 0,\n      ...props2\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({ prop, bindable }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\")\n      }))\n    };\n  },\n  watch({ track, send, prop }) {\n    track([() => prop(\"startMs\")], () => {\n      send({ type: \"RESTART\" });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({ context }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({ computed }) => formatTime(computed(\"time\")),\n    progressPercent: memo(\n      ({ context, prop }) => [context.get(\"currentMs\"), prop(\"targetMs\"), prop(\"startMs\"), prop(\"countdown\")],\n      ([currentMs, targetMs = 0, startMs, countdown]) => {\n        const percent = countdown ? toPercent(currentMs, targetMs, startMs) : toPercent(currentMs, startMs, targetMs);\n        return clampValue(percent, 0, 1);\n      }\n    )\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [\n          {\n            target: \"idle\",\n            guard: \"hasReachedTarget\",\n            actions: [\"invokeOnComplete\"]\n          },\n          {\n            actions: [\"updateTime\", \"invokeOnTick\"]\n          }\n        ],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({ prop, send }) {\n        return setRafInterval(({ deltaMs }) => {\n          send({ type: \"TICK\", deltaMs });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({ send }) {\n        return setRafTimeout(() => {\n          send({ type: \"CONTINUE\" });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({ context, prop, event }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", (prev) => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime({ context, prop }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({ context, prop, computed }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({ prop }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({ context, prop }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const { days, hours, minutes, seconds } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const { startMs, targetMs, countdown, interval } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(`[timer] Invalid interval: ${interval}. Must be a positive number.`);\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(`[timer] Invalid startMs: ${startMs}. Must be a non-negative number.`);\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(`[timer] Invalid targetMs: ${targetMs}. Must be a non-negative number.`);\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(\n        `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(\n        `[timer] Invalid stopwatch configuration: startMs (${startMs}) must be less than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(\n      `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than 0 when no targetMs is provided.`\n    );\n  }\n}\nvar segments = /* @__PURE__ */ new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some((key) => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const { days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\n  \"autoStart\",\n  \"countdown\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interval\",\n  \"onComplete\",\n  \"onTick\",\n  \"startMs\",\n  \"targetMs\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, parse, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}