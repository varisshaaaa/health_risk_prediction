{"ast":null,"code":"\"use strict\";\n\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const {\n      prefix,\n      allTokens,\n      formatCssVar,\n      formatTokenName,\n      registerToken\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"spacing\");\n    tokens.forEach(token => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const newPath = [...token.path];\n      const lastPath = newPath[newPath.length - 1];\n      if (lastPath != null) {\n        newPath[newPath.length - 1] = `-${lastPath}`;\n      }\n      const nextToken = {\n        ...token,\n        value: calc.negate(originalVar.ref),\n        name: formatTokenName(newPath),\n        path: newPath,\n        extensions: {\n          ...token.extensions,\n          negative: true,\n          prop: `-${token.extensions.prop}`,\n          originalPath\n        }\n      };\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */new Set([\"spacing\", \"sizes\", \"borderWidths\", \"fontSizes\", \"radii\"]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter(token => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach(token => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const {\n      allTokens,\n      registerToken,\n      formatTokenName\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"colors\");\n    const keys = /* @__PURE__ */new Map();\n    const colorPalettes = /* @__PURE__ */new Map();\n    tokens.forEach(token => {\n      const {\n        colorPalette\n      } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach(keyPath => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach(colorPaletteRoot => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach(segments => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(token => token.value !== \"\");\n  }\n};\nconst tokenMiddlewares = [addNegativeTokens, addVirtualPalette, addPixelUnit, removeEmptyTokens];\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };","map":{"version":3,"names":["isString","calc","toPx","addNegativeTokens","enforce","transform","dictionary","prefix","allTokens","formatCssVar","formatTokenName","registerToken","tokens","filter","extensions","category","forEach","token","originalPath","path","slice","originalVar","value","newPath","lastPath","length","nextToken","negate","ref","name","negative","prop","units","Set","addPixelUnit","has","Object","assign","pixelValue","addVirtualPalette","keys","Map","colorPalettes","colorPalette","keyPath","set","roots","colorPaletteRoot","colorPaletteList","get","push","default","Boolean","concat","segments","originalValue","condition","virtual","removeEmptyTokens","tokenMiddlewares"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js"],"sourcesContent":["\"use strict\";\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\n\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"spacing\"\n    );\n    tokens.forEach((token) => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const newPath = [...token.path];\n      const lastPath = newPath[newPath.length - 1];\n      if (lastPath != null) {\n        newPath[newPath.length - 1] = `-${lastPath}`;\n      }\n      const nextToken = {\n        ...token,\n        value: calc.negate(originalVar.ref),\n        name: formatTokenName(newPath),\n        path: newPath,\n        extensions: {\n          ...token.extensions,\n          negative: true,\n          prop: `-${token.extensions.prop}`,\n          originalPath\n        }\n      };\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */ new Set([\n  \"spacing\",\n  \"sizes\",\n  \"borderWidths\",\n  \"fontSizes\",\n  \"radii\"\n]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter((token) => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach((token) => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const { allTokens, registerToken, formatTokenName } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"colors\"\n    );\n    const keys = /* @__PURE__ */ new Map();\n    const colorPalettes = /* @__PURE__ */ new Map();\n    tokens.forEach((token) => {\n      const { colorPalette } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach((keyPath) => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach((colorPaletteRoot) => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach((segments) => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(\n      (token) => token.value !== \"\"\n    );\n  }\n};\nconst tokenMiddlewares = [\n  addNegativeTokens,\n  addVirtualPalette,\n  addPixelUnit,\n  removeEmptyTokens\n];\n\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}