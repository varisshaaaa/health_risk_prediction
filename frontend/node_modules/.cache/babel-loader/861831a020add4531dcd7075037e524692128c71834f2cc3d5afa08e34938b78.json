{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/caret.ts\nfunction isCaretAtStart(input) {\n  if (!input) return false;\n  try {\n    return input.selectionStart === 0 && input.selectionEnd === 0;\n  } catch {\n    return input.value === \"\";\n  }\n}\nfunction setCaretToEnd(input) {\n  if (!input) return;\n  const start = input.selectionStart ?? 0;\n  const end = input.selectionEnd ?? 0;\n  if (Math.abs(end - start) !== 0) return;\n  if (start !== 0) return;\n  input.setSelectionRange(input.value.length, input.value.length);\n}\n\n// src/shared.ts\nvar clamp = value => Math.max(0, Math.min(1, value));\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nvar pipe = (...fns) => arg => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\nvar isObject = v => typeof v === \"object\" && v !== null;\nvar MAX_Z_INDEX = 2147483647;\nvar dataAttr = guard => guard ? \"\" : void 0;\nvar ariaAttr = guard => guard ? \"true\" : void 0;\n\n// src/node.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isHTMLElement = el => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = el => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = el => isObject(el) && el === el.window;\nvar isVisualViewport = el => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = node => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = el => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = el => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\nvar isInputElement = el => isHTMLElement(el) && el.localName === \"input\";\nvar isAnchorElement = el => !!el?.matches(\"a[href]\");\nvar isElementVisible = el => {\n  if (!isHTMLElement(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n};\nfunction isActiveElement(element) {\n  if (!element) return false;\n  const rootNode = element.getRootNode();\n  return getActiveElement(rootNode) === element;\n}\nvar TEXTAREA_SELECT_REGEX = /(textarea|select)/;\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) return false;\n  try {\n    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute(\"contenteditable\") === \"true\" || el.getAttribute(\"contenteditable\") === \"\";\n  } catch {\n    return false;\n  }\n}\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  const rootNode = child.getRootNode?.();\n  if (parent === child) return true;\n  if (parent.contains(child)) return true;\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) return true;\n      next = next.parentNode || next.host;\n    }\n  }\n  return false;\n}\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(rootNode) {\n  let activeElement = rootNode.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement;\n    if (!el || el === activeElement) break;else activeElement = el;\n  }\n  return activeElement;\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") return node;\n  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getRootNode(node) {\n  let result;\n  try {\n    result = node.getRootNode({\n      composed: true\n    });\n    if (isDocument(result) || isShadowRoot(result)) return result;\n  } catch {}\n  return node.ownerDocument ?? document;\n}\n\n// src/computed-style.ts\nvar styleCache = /* @__PURE__ */new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/controller.ts\nvar INTERACTIVE_CONTAINER_ROLE = /* @__PURE__ */new Set([\"menu\", \"listbox\", \"dialog\", \"grid\", \"tree\", \"region\"]);\nvar isInteractiveContainerRole = role => INTERACTIVE_CONTAINER_ROLE.has(role);\nvar getAriaControls = element => element.getAttribute(\"aria-controls\")?.split(\" \") || [];\nfunction isControlledElement(container, element) {\n  const visitedIds = /* @__PURE__ */new Set();\n  const rootNode = getRootNode(container);\n  const checkElement = searchRoot => {\n    const controllingElements = searchRoot.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && isInteractiveContainerRole(role) && !modal) {\n            if (controlledElement === element || controlledElement.contains(element)) {\n              return true;\n            }\n            if (checkElement(controlledElement)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  return checkElement(container);\n}\nfunction findControlledElements(searchRoot, callback) {\n  const rootNode = getRootNode(searchRoot);\n  const visitedIds = /* @__PURE__ */new Set();\n  const findRecursive = root => {\n    const controllingElements = root.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && INTERACTIVE_CONTAINER_ROLE.has(role) && !modal) {\n            callback(controlledElement);\n            findRecursive(controlledElement);\n          }\n        }\n      }\n    }\n  };\n  findRecursive(searchRoot);\n}\nfunction getControlledElements(container) {\n  const controlledElements = /* @__PURE__ */new Set();\n  findControlledElements(container, controlledElement => {\n    if (!container.contains(controlledElement)) {\n      controlledElements.add(controlledElement);\n    }\n  });\n  return Array.from(controlledElements);\n}\nfunction isInteractiveContainerElement(element) {\n  const role = element.getAttribute(\"role\");\n  return Boolean(role && INTERACTIVE_CONTAINER_ROLE.has(role));\n}\nfunction isControllerElement(element) {\n  return element.hasAttribute(\"aria-controls\") && element.getAttribute(\"aria-expanded\") === \"true\";\n}\nfunction hasControllerElements(element) {\n  if (isControllerElement(element)) return true;\n  return Boolean(element.querySelector?.('[aria-controls][aria-expanded=\"true\"]'));\n}\nfunction isControlledByExpandedController(element) {\n  if (!element.id) return false;\n  const rootNode = getRootNode(element);\n  const escapedId = CSS.escape(element.id);\n  const selector = `[aria-controls~=\"${escapedId}\"][aria-expanded=\"true\"], [aria-controls=\"${escapedId}\"][aria-expanded=\"true\"]`;\n  const controller = rootNode.querySelector(selector);\n  return Boolean(controller && isInteractiveContainerElement(element));\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const {\n    type,\n    quality = 0.92,\n    background\n  } = opts;\n  if (!svg) throw new Error(\"[zag-js > getDataUrl]: Could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const svgBounds = svg.getBoundingClientRect();\n  const svgClone = svg.cloneNode(true);\n  if (!svgClone.hasAttribute(\"viewBox\")) {\n    svgClone.setAttribute(\"viewBox\", `0 0 ${svgBounds.width} ${svgBounds.height}`);\n  }\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svgClone);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString).then(str => {\n      svgClone.remove();\n      return str;\n    });\n  }\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  if (type === \"image/jpeg\" || background) {\n    context.fillStyle = background || \"white\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return new Promise(resolve => {\n    image.onload = () => {\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height);\n      resolve(canvas.toDataURL(type, quality));\n      svgClone.remove();\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nfunction getUserAgent() {\n  const ua2 = navigator.userAgentData;\n  if (ua2 && Array.isArray(ua2.brands)) {\n    return ua2.brands.map(({\n      brand,\n      version\n    }) => `${brand}/${version}`).join(\" \");\n  }\n  return navigator.userAgent;\n}\nvar pt = v => isDom() && v.test(getPlatform());\nvar ua = v => isDom() && v.test(getUserAgent());\nvar vn = v => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isIPhone = () => pt(/^iPhone/i);\nvar isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;\nvar isIos = () => isIPhone() || isIPad();\nvar isApple = () => isMac() || isIos();\nvar isMac = () => pt(/^Mac/i);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/Firefox/i);\nvar isChrome = () => ua(/Chrome/i);\nvar isWebKit = () => ua(/AppleWebKit/i) && !isChrome();\nvar isAndroid = () => ua(/Android/i);\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const {\n    selectionStart,\n    selectionEnd,\n    value\n  } = event.currentTarget;\n  const data = event.data;\n  return value.slice(0, selectionStart) + (data ?? \"\") + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const validElement = element.matches(\"a[href], button[type='submit'], input[type='submit']\");\n  if (!validElement) return false;\n  const isMiddleClick = event.button === 1;\n  const isModKeyClick = isCtrlOrMetaKey(event);\n  return isMiddleClick || isModKeyClick;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return getNativeEvent(event).isComposing || event.keyCode === 229;\n}\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isCtrlOrMetaKey(e) {\n  if (isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.pointerType === \"\" && e.isTrusted) return true;\n  if (isAndroid() && e.pointerType) {\n    return e.type === \"click\" && e.buttons === 1;\n  }\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = e => e.button === 0;\nvar isContextMenuEvent = e => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = e => e.ctrlKey || e.altKey || e.metaKey;\nvar isTouchEvent = event => \"touches\" in event && event.touches.length > 0;\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const {\n    dir = \"ltr\",\n    orientation = \"horizontal\"\n  } = options;\n  let key = event.key;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];\n  return key;\n}\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\nvar pageKeys = /* @__PURE__ */new Set([\"PageUp\", \"PageDown\"]);\nvar arrowKeys = /* @__PURE__ */new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = pageKeys.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\nfunction getEventPoint(event, type = \"client\") {\n  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n  return {\n    x: point[`${type}X`],\n    y: point[`${type}Y`]\n  };\n}\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\nvar isSelfTarget = event => {\n  const composedPath = getComposedPath(event);\n  const target = composedPath?.[0] ?? event.target;\n  return event.currentTarget === target;\n};\n\n// src/form.ts\nfunction getDescriptor(el, options) {\n  const {\n    type = \"HTMLInputElement\",\n    property = \"value\"\n  } = options;\n  const proto = getWindow(el)[type].prototype;\n  return Object.getOwnPropertyDescriptor(proto, property) ?? {};\n}\nfunction getElementType(el) {\n  if (el.localName === \"input\") return \"HTMLInputElement\";\n  if (el.localName === \"textarea\") return \"HTMLTextAreaElement\";\n  if (el.localName === \"select\") return \"HTMLSelectElement\";\n}\nfunction setElementValue(el, value, property = \"value\") {\n  if (!el) return;\n  const type = getElementType(el);\n  if (type) {\n    const descriptor = getDescriptor(el, {\n      type,\n      property\n    });\n    descriptor.set?.call(el, value);\n  }\n  el.setAttribute(property, value);\n}\nfunction setElementChecked(el, checked) {\n  if (!el) return;\n  const descriptor = getDescriptor(el, {\n    type: \"HTMLInputElement\",\n    property: \"checked\"\n  });\n  descriptor.set?.call(el, checked);\n  if (checked) el.setAttribute(\"checked\", \"\");else el.removeAttribute(\"checked\");\n}\nfunction dispatchInputValueEvent(el, options) {\n  const {\n    value,\n    bubbles = true\n  } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementValue(el, `${value}`);\n  el.dispatchEvent(new win.Event(\"input\", {\n    bubbles\n  }));\n}\nfunction dispatchInputCheckedEvent(el, options) {\n  const {\n    checked,\n    bubbles = true\n  } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementChecked(el, checked);\n  el.dispatchEvent(new win.Event(\"click\", {\n    bubbles\n  }));\n}\nfunction getClosestForm(el) {\n  return isFormElement(el) ? el.form : el.closest(\"form\");\n}\nfunction isFormElement(el) {\n  return el.matches(\"textarea, input, select, button\");\n}\nfunction trackFormReset(el, callback) {\n  if (!el) return;\n  const form = getClosestForm(el);\n  const onReset = e => {\n    if (e.defaultPrevented) return;\n    callback();\n  };\n  form?.addEventListener(\"reset\", onReset, {\n    passive: true\n  });\n  return () => form?.removeEventListener(\"reset\", onReset);\n}\nfunction trackFieldsetDisabled(el, callback) {\n  const fieldset = el?.closest(\"fieldset\");\n  if (!fieldset) return;\n  callback(fieldset.disabled);\n  const win = getWindow(fieldset);\n  const obs = new win.MutationObserver(() => callback(fieldset.disabled));\n  obs.observe(fieldset, {\n    attributes: true,\n    attributeFilter: [\"disabled\"]\n  });\n  return () => obs.disconnect();\n}\nfunction trackFormControl(el, options) {\n  if (!el) return;\n  const {\n    onFieldsetDisabledChange,\n    onFormReset\n  } = options;\n  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];\n  return () => cleanups.forEach(cleanup => cleanup?.());\n}\n\n// src/tabbable.ts\nvar isFrame = el => isHTMLElement(el) && el.tagName === \"IFRAME\";\nvar NATURALLY_TABBABLE_REGEX = /^(audio|video|details)$/;\nfunction parseTabIndex(el) {\n  const attr = el.getAttribute(\"tabindex\");\n  if (!attr) return NaN;\n  return parseInt(attr, 10);\n}\nvar hasTabIndex = el => !Number.isNaN(parseTabIndex(el));\nvar hasNegativeTabIndex = el => parseTabIndex(el) < 0;\nfunction getShadowRootForNode(element, getShadowRoot) {\n  if (!getShadowRoot) return null;\n  if (getShadowRoot === true) {\n    return element.shadowRoot || null;\n  }\n  const result = getShadowRoot(element);\n  return (result === true ? element.shadowRoot : result) || null;\n}\nfunction collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {\n  const allElements = [...elements];\n  const toProcess = [...elements];\n  const processed = /* @__PURE__ */new Set();\n  const positionMap = /* @__PURE__ */new Map();\n  elements.forEach((el, i) => positionMap.set(el, i));\n  let processIndex = 0;\n  while (processIndex < toProcess.length) {\n    const element = toProcess[processIndex++];\n    if (!element || processed.has(element)) continue;\n    processed.add(element);\n    const shadowRoot = getShadowRootForNode(element, getShadowRoot);\n    if (shadowRoot) {\n      const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);\n      const hostIndex = positionMap.get(element);\n      if (hostIndex !== void 0) {\n        const insertPosition = hostIndex + 1;\n        allElements.splice(insertPosition, 0, ...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n        for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {\n          positionMap.set(allElements[i], i);\n        }\n      } else {\n        const insertPosition = allElements.length;\n        allElements.push(...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n      }\n      toProcess.push(...shadowElements);\n    }\n  }\n  return allElements;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, options = {}) => {\n  if (!container) return [];\n  const {\n    includeContainer = false,\n    getShadowRoot\n  } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = [];\n  for (const element of elements) {\n    if (!isFocusable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.push(...getFocusables(frameBody, {\n        getShadowRoot\n      }));\n      continue;\n    }\n    focusableElements.push(element);\n  }\n  if (getShadowRoot) {\n    return collectElementsWithShadowDOM(focusableElements, getShadowRoot, isFocusable);\n  }\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!isHTMLElement(element) || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isElementVisible(element);\n}\nfunction getFirstFocusable(container, options = {}) {\n  const [first] = getFocusables(container, options);\n  return first || null;\n}\nfunction getTabbables(container, options = {}) {\n  if (!container) return [];\n  const {\n    includeContainer,\n    getShadowRoot\n  } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  if (includeContainer && isTabbable(container)) {\n    elements.unshift(container);\n  }\n  const tabbableElements = [];\n  for (const element of elements) {\n    if (!isTabbable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      tabbableElements.push(...getTabbables(frameBody, {\n        getShadowRoot\n      }));\n      continue;\n    }\n    tabbableElements.push(element);\n  }\n  if (getShadowRoot) {\n    const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);\n    if (!allElements.length && includeContainer) {\n      return elements;\n    }\n    return allElements;\n  }\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (isHTMLElement(el) && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, options = {}) {\n  const [first] = getTabbables(container, options);\n  return first || null;\n}\nfunction getLastTabbable(container, options = {}) {\n  const elements = getTabbables(container, options);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, options = {}) {\n  const elements = getTabbables(container, options);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, options = {}) {\n  const {\n    current,\n    getShadowRoot\n  } = options;\n  const tabbables = getTabbables(container, {\n    getShadowRoot\n  });\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? getActiveElement(doc);\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\nfunction getTabIndex(node) {\n  if (node.tabIndex < 0) {\n    if ((NATURALLY_TABBABLE_REGEX.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const {\n    root,\n    getInitialEl,\n    filter,\n    enabled = true\n  } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  if (isActiveElement(firstTabbable) && event.shiftKey) return false;\n  if (isActiveElement(lastTabbable) && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/raf.ts\nvar AnimationFrame = class _AnimationFrame {\n  constructor() {\n    __publicField(this, \"id\", null);\n    __publicField(this, \"fn_cleanup\");\n    __publicField(this, \"cleanup\", () => {\n      this.cancel();\n    });\n  }\n  static create() {\n    return new _AnimationFrame();\n  }\n  request(fn) {\n    this.cancel();\n    this.id = globalThis.requestAnimationFrame(() => {\n      this.id = null;\n      this.fn_cleanup = fn?.();\n    });\n  }\n  cancel() {\n    if (this.id !== null) {\n      globalThis.cancelAnimationFrame(this.id);\n      this.id = null;\n    }\n    this.fn_cleanup?.();\n    this.fn_cleanup = void 0;\n  }\n  isActive() {\n    return this.id !== null;\n  }\n};\nfunction raf(fn) {\n  const frame = AnimationFrame.create();\n  frame.request(fn);\n  return frame.cleanup;\n}\nfunction nextTick(fn) {\n  const set = /* @__PURE__ */new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set.forEach(fn2 => fn2());\n  };\n}\nfunction queueBeforeEvent(el, type, cb) {\n  const cancelTimer = raf(() => {\n    el.removeEventListener(type, exec, true);\n    cb();\n  });\n  const exec = () => {\n    cancelTimer();\n    cb();\n  };\n  el.addEventListener(type, exec, {\n    once: true,\n    capture: true\n  });\n  return cancelTimer;\n}\n\n// src/mutation-observer.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const {\n    attributes,\n    callback: fn\n  } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(changes => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, {\n    attributes: true,\n    attributeFilter: attributes\n  });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n    cleanups.push(observeAttributesImpl(node, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\nfunction observeChildrenImpl(node, options) {\n  const {\n    callback: fn\n  } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, {\n    childList: true,\n    subtree: true\n  });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n    cleanups.push(observeChildrenImpl(node, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\n\n// src/navigate.ts\nfunction navigate(items, current, options = {}) {\n  if (!current) return null;\n  const {\n    orientation = \"both\",\n    loop = true,\n    dir = \"ltr\",\n    key\n  } = options;\n  if (!items.length || !key) return null;\n  const isVertical = key === \"ArrowUp\" || key === \"ArrowDown\";\n  const isHorizontal = key === \"ArrowLeft\" || key === \"ArrowRight\";\n  if (!isVertical && !isHorizontal && key !== \"Home\" && key !== \"End\") return null;\n  if (orientation === \"vertical\" && isHorizontal || orientation === \"horizontal\" && isVertical) return null;\n  if (key === \"Home\") return items[0] || null;\n  if (key === \"End\") return items[items.length - 1] || null;\n  const idx = items.indexOf(current);\n  if (idx === -1) return null;\n  let isForward;\n  if (orientation === \"both\") {\n    isForward = key === \"ArrowDown\" || (dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\");\n  } else {\n    isForward = isVertical ? key === \"ArrowDown\" : dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\";\n  }\n  const nextIdx = isForward ? loop ? (idx + 1) % items.length : Math.min(idx + 1, items.length - 1) : loop ? (idx - 1 + items.length) % items.length : Math.max(0, idx - 1);\n  return items[nextIdx] || null;\n}\nfunction clickIfLink(el) {\n  const click = () => {\n    const win = getWindow(el);\n    el.dispatchEvent(new win.MouseEvent(\"click\"));\n  };\n  if (isFirefox()) {\n    queueBeforeEvent(el, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) return getDocument(parentNode).body;\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getElementRect = el => {\n  if (isHTMLElement(el)) return el.getBoundingClientRect();\n  if (isVisualViewport(el)) return {\n    top: 0,\n    left: 0,\n    bottom: el.height,\n    right: el.width\n  };\n  return {\n    top: 0,\n    left: 0,\n    bottom: el.innerHeight,\n    right: el.innerWidth\n  };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getElementRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nvar nonOverflowValues = /* @__PURE__ */new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !nonOverflowValues.has(display);\n}\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const {\n    rootEl,\n    ...scrollOptions\n  } = options || {};\n  if (!el || !rootEl) return;\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;\n  el.scrollIntoView(scrollOptions);\n}\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\n\n// src/point.ts\nfunction getRelativePoint(point, element) {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  const offset = {\n    x: point.x - left,\n    y: point.y - top\n  };\n  const percent = {\n    x: clamp(offset.x / width),\n    y: clamp(offset.y / height)\n  };\n  function getPercentValue(options = {}) {\n    const {\n      dir = \"ltr\",\n      orientation = \"horizontal\",\n      inverted\n    } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return {\n    offset,\n    percent,\n    getPercentValue\n  };\n}\n\n// src/pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occurred:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {}\n  const cleanup = [addDomEvent(doc, \"pointerlockchange\", onPointerChange, false), addDomEvent(doc, \"pointerlockerror\", onPointerError, false)];\n  return () => {\n    cleanup.forEach(cleanup2 => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/text-selection.ts\nvar state = \"default\";\nvar userSelect = \"\";\nvar elementMap = /* @__PURE__ */new WeakMap();\nfunction disableTextSelectionImpl(options = {}) {\n  const {\n    target,\n    doc\n  } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect;\n      rootEl.style.webkitUserSelect = \"none\";\n    }\n    state = \"disabled\";\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n  return () => restoreTextSelection({\n    target,\n    doc: docNode\n  });\n}\nfunction restoreTextSelection(options = {}) {\n  const {\n    target,\n    doc\n  } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state !== \"disabled\") return;\n    state = \"restoring\";\n    setTimeout(() => {\n      nextTick(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\";\n          }\n          userSelect = \"\";\n          state = \"default\";\n        }\n      });\n    }, 300);\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target);\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\";\n      }\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\");\n      }\n      elementMap.delete(target);\n    }\n  }\n}\nfunction disableTextSelection(options = {}) {\n  const {\n    defer,\n    target,\n    ...restOptions\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const node = typeof target === \"function\" ? target() : target;\n    cleanups.push(disableTextSelectionImpl({\n      ...restOptions,\n      target: node\n    }));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\n\n// src/pointer-move.ts\nfunction trackPointerMove(doc, handlers) {\n  const {\n    onPointerMove,\n    onPointerUp\n  } = handlers;\n  const handleMove = event => {\n    const point = getEventPoint(event);\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.buttons === 0) {\n      handleUp(event);\n      return;\n    }\n    onPointerMove({\n      point,\n      event\n    });\n  };\n  const handleUp = event => {\n    const point = getEventPoint(event);\n    onPointerUp({\n      point,\n      event\n    });\n  };\n  const cleanups = [addDomEvent(doc, \"pointermove\", handleMove, false), addDomEvent(doc, \"pointerup\", handleUp, false), addDomEvent(doc, \"pointercancel\", handleUp, false), addDomEvent(doc, \"contextmenu\", handleUp, false), disableTextSelection({\n    doc\n  })];\n  return () => {\n    cleanups.forEach(cleanup => cleanup());\n  };\n}\n\n// src/press.ts\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = e => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = event => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = startEvent => {\n    removeEndListeners();\n    const endPointerPress = endEvent => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, {\n      passive: !onPress,\n      once: true\n    });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd,\n      once: true\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (isActiveElement(keyboardNode) && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, {\n    passive: !onPressStart\n  });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = keydownEvent => {\n      if (!isValidKey(keydownEvent)) return;\n      const handleKeyup = keyupEvent => {\n        if (!isValidKey(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return () => {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const {\n    triggerElement,\n    onFocus,\n    onFocusEnter,\n    getShadowRoot\n  } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, {\n      includeContainer: true,\n      getShadowRoot\n    });\n    const nextTabbableAfterTrigger = getNextTabbable(body, {\n      current: triggerElement,\n      getShadowRoot\n    });\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && isActiveElement(nextTabbableAfterTrigger)) {\n      onFocusEnter?.();\n      elementToFocus = lastTabbable;\n    } else if (event.shiftKey && (isActiveElement(firstTabbable) || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && isActiveElement(triggerElement)) {\n      onFocusEnter?.();\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (isActiveElement(lastTabbable) || noTabbableElements)) {\n      elementToFocus = nextTabbableAfterTrigger;\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  return addDomEvent(doc, \"keydown\", onKeyDown, true);\n}\nfunction proxyTabFocus(container, options) {\n  const {\n    defer,\n    triggerElement,\n    ...restOptions\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const node = typeof container === \"function\" ? container() : container;\n    const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n    cleanups.push(proxyTabFocusImpl(node, {\n      triggerElement: trigger,\n      ...restOptions\n    }));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\nvar defaultItemToId = v => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find(item => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/resize-observer.ts\nfunction createSharedResizeObserver(options) {\n  const listeners = /* @__PURE__ */new WeakMap();\n  let observer;\n  const entries = /* @__PURE__ */new WeakMap();\n  const getObserver = win => {\n    if (observer) return observer;\n    observer = new win.ResizeObserver(observedEntries => {\n      for (const entry of observedEntries) {\n        entries.set(entry.target, entry);\n        const elementListeners = listeners.get(entry.target);\n        if (elementListeners) {\n          for (const listener of elementListeners) {\n            listener(entry);\n          }\n        }\n      }\n    });\n    return observer;\n  };\n  const observe = (element, listener) => {\n    let elementListeners = listeners.get(element) || /* @__PURE__ */new Set();\n    elementListeners.add(listener);\n    listeners.set(element, elementListeners);\n    const win = getWindow(element);\n    getObserver(win).observe(element, options);\n    return () => {\n      const elementListeners2 = listeners.get(element);\n      if (!elementListeners2) return;\n      elementListeners2.delete(listener);\n      if (elementListeners2.size === 0) {\n        listeners.delete(element);\n        getObserver(win).unobserve(element);\n      }\n    };\n  };\n  const unobserve = element => {\n    listeners.delete(element);\n    observer?.unobserve(element);\n  };\n  return {\n    observe,\n    unobserve\n  };\n}\nvar resizeObserverContentBox = /* @__PURE__ */createSharedResizeObserver({\n  box: \"content-box\"\n});\nvar resizeObserverBorderBox = /* @__PURE__ */createSharedResizeObserver({\n  box: \"border-box\"\n});\nvar resizeObserverDevicePixelContentBox = /* @__PURE__ */createSharedResizeObserver({\n  box: \"device-pixel-content-box\"\n});\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: ctx => ctx.getRootNode?.() ?? document,\n    getDoc: ctx => getDocument(dom.getRootNode(ctx)),\n    getWin: ctx => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: ctx => getActiveElement(dom.getRootNode(ctx)),\n    isActiveElement,\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      setElementValue(elem, value.toString());\n    }\n  };\n  return {\n    ...dom,\n    ...methods\n  };\n}\n\n// src/searchable.ts\nvar sanitize = str => str.split(\"\").map(char => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\nvar getValueText = el => {\n  return sanitize(el.dataset?.valuetext ?? el.textContent ?? \"\");\n};\nvar match = (valueText, query2) => {\n  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter(item => itemToId(item) !== currentId);\n  }\n  return items.find(item => match(getValueText(item), text));\n}\n\n// src/set.ts\nfunction setAttribute(el, attr, v) {\n  const prev = el.getAttribute(attr);\n  const exists = prev != null;\n  el.setAttribute(attr, v);\n  return () => {\n    if (!exists) {\n      el.removeAttribute(attr);\n    } else {\n      el.setAttribute(attr, prev);\n    }\n  };\n}\nfunction setProperty(el, prop, v) {\n  const exists = prop in el;\n  const prev = el[prop];\n  el[prop] = v;\n  return () => {\n    if (!exists) {\n      delete el[prop];\n    } else {\n      el[prop] = prev;\n    }\n  };\n}\nfunction setStyle(el, style) {\n  if (!el) return noop;\n  const prev = Object.keys(style).reduce((acc, key) => {\n    acc[key] = el.style.getPropertyValue(key);\n    return acc;\n  }, {});\n  Object.assign(el.style, style);\n  return () => {\n    Object.assign(el.style, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\nfunction setStyleProperty(el, prop, value) {\n  if (!el) return noop;\n  const prev = el.style.getPropertyValue(prop);\n  el.style.setProperty(prop, value);\n  return () => {\n    el.style.setProperty(prop, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\n\n// src/typeahead.ts\nfunction getByTypeaheadImpl(baseItems, options) {\n  const {\n    state: state2,\n    activeId,\n    key,\n    timeout = 350,\n    itemToId\n  } = options;\n  const search = state2.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = baseItems.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state2.timer);\n    state2.timer = -1;\n  }\n  function update(value) {\n    state2.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state2.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */Object.assign(getByTypeaheadImpl, {\n  defaultOptions: {\n    keysSoFar: \"\",\n    timer: -1\n  },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\nfunction setVisuallyHidden(el) {\n  Object.assign(el.style, visuallyHiddenStyle);\n}\n\n// src/wait-for.ts\nfunction waitForPromise(promise, controller, timeout) {\n  const {\n    signal\n  } = controller;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Timeout of ${timeout}ms exceeded`));\n    }, timeout);\n    signal.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(new Error(\"Promise aborted\"));\n    });\n    promise.then(result => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    }).catch(error => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  });\n  const abort = () => controller.abort();\n  return [wrappedPromise, abort];\n}\nfunction waitForElement(target, options) {\n  const {\n    timeout,\n    rootNode\n  } = options;\n  const win = getWindow(rootNode);\n  const doc = getDocument(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(new Promise(resolve => {\n    const el = target();\n    if (el) {\n      resolve(el);\n      return;\n    }\n    const observer = new win.MutationObserver(() => {\n      const el2 = target();\n      if (el2 && el2.isConnected) {\n        observer.disconnect();\n        resolve(el2);\n      }\n    });\n    observer.observe(doc.body, {\n      childList: true,\n      subtree: true\n    });\n  }), controller, timeout);\n}\nexport { AnimationFrame, MAX_Z_INDEX, addDomEvent, ariaAttr, clickIfLink, contains, createScope, dataAttr, defaultItemToId, disableTextSelection, dispatchInputCheckedEvent, dispatchInputValueEvent, findControlledElements, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getControlledElements, getDataUrl, getDocument, getDocumentElement, getEventKey, getEventPoint, getEventStep, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNativeEvent, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getRelativePoint, getRootNode, getScrollPosition, getTabIndex, getTabbableEdges, getTabbables, getUserAgent, getWindow, hasControllerElements, indexOfId, isActiveElement, isAnchorElement, isAndroid, isApple, isCaretAtStart, isChrome, isComposingEvent, isContextMenuEvent, isControlledByExpandedController, isControlledElement, isControllerElement, isCtrlOrMetaKey, isDocument, isDom, isDownloadingEvent, isEditableElement, isElementVisible, isFirefox, isFocusable, isHTMLElement, isIPad, isIPhone, isInView, isInputElement, isInteractiveContainerElement, isIos, isKeyboardClick, isLeftClick, isMac, isModifierKey, isNode, isOpeningInNewTab, isOverflowElement, isPrintableKey, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isTouchEvent, isValidTabEvent, isVirtualClick, isVirtualPointerEvent, isVisualViewport, isWebKit, isWindow, itemById, navigate, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, queueBeforeEvent, raf, requestPointerLock, resizeObserverBorderBox, resizeObserverContentBox, resizeObserverDevicePixelContentBox, restoreTextSelection, scrollIntoView, setAttribute, setCaretToEnd, setElementChecked, setElementValue, setProperty, setStyle, setStyleProperty, setVisuallyHidden, trackFormControl, trackPointerMove, trackPress, trackVisualViewport, visuallyHiddenStyle, waitForElement, waitForPromise };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","isCaretAtStart","input","selectionStart","selectionEnd","setCaretToEnd","start","end","Math","abs","setSelectionRange","length","clamp","max","min","wrap","v","idx","map","_","index","pipe","fns","arg","reduce","acc","fn","noop","isObject","MAX_Z_INDEX","dataAttr","guard","ariaAttr","ELEMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","isHTMLElement","el","nodeType","nodeName","isDocument","isWindow","window","isVisualViewport","constructor","name","getNodeName","node","localName","isRootElement","includes","isNode","isShadowRoot","isInputElement","isAnchorElement","matches","isElementVisible","offsetWidth","offsetHeight","getClientRects","isActiveElement","element","rootNode","getRootNode","getActiveElement","TEXTAREA_SELECT_REGEX","isEditableElement","test","isContentEditable","getAttribute","contains","parent","child","next","parentNode","host","getDocument","document","ownerDocument","getDocumentElement","documentElement","getWindow","defaultView","activeElement","shadowRoot","getParentNode","result","assignedSlot","composed","styleCache","WeakMap","getComputedStyle","has","set","get","INTERACTIVE_CONTAINER_ROLE","Set","isInteractiveContainerRole","role","getAriaControls","split","isControlledElement","container","visitedIds","checkElement","searchRoot","controllingElements","querySelectorAll","controller","controlledIds","id","add","controlledElement","getElementById","modal","findControlledElements","callback","findRecursive","root","getControlledElements","controlledElements","Array","from","isInteractiveContainerElement","Boolean","isControllerElement","hasAttribute","hasControllerElements","querySelector","isControlledByExpandedController","escapedId","CSS","escape","selector","getDataUrl","svg","opts","type","quality","background","Error","win","doc","svgBounds","getBoundingClientRect","svgClone","cloneNode","setAttribute","width","height","serializer","XMLSerializer","source","serializeToString","svgString","encodeURIComponent","Promise","resolve","then","str","remove","dpr","devicePixelRatio","canvas","createElement","image","Image","src","context","getContext","fillStyle","fillRect","onload","drawImage","toDataURL","isDom","getPlatform","agent","navigator","userAgentData","platform","getUserAgent","ua2","isArray","brands","brand","version","join","userAgent","pt","ua","vn","vendor","isTouchDevice","maxTouchPoints","isIPhone","isIPad","isMac","isIos","isApple","isSafari","isFirefox","isChrome","isWebKit","isAndroid","getBeforeInputValue","event","currentTarget","data","slice","getComposedPath","composedPath","nativeEvent","getEventTarget","target","isOpeningInNewTab","validElement","isMiddleClick","button","isModKeyClick","isCtrlOrMetaKey","isDownloadingEvent","altKey","isComposingEvent","getNativeEvent","isComposing","keyCode","isKeyboardClick","e","detail","clientX","clientY","metaKey","ctrlKey","isPrintableKey","isVirtualPointerEvent","pressure","pointerType","isVirtualClick","isTrusted","buttons","isLeftClick","isContextMenuEvent","isModifierKey","isTouchEvent","touches","keyMap","Up","Down","Esc","Left","Right","rtlKeyMap","ArrowLeft","ArrowRight","getEventKey","options","dir","orientation","isRtl","pageKeys","arrowKeys","getEventStep","isPageKey","isSkipKey","shiftKey","getEventPoint","point","changedTouches","x","y","addDomEvent","eventName","handler","addEventListener","removeEventListener","isSelfTarget","getDescriptor","property","proto","prototype","getOwnPropertyDescriptor","getElementType","setElementValue","descriptor","call","setElementChecked","checked","removeAttribute","dispatchInputValueEvent","bubbles","HTMLInputElement","dispatchEvent","Event","dispatchInputCheckedEvent","getClosestForm","isFormElement","form","closest","trackFormReset","onReset","defaultPrevented","passive","trackFieldsetDisabled","fieldset","disabled","obs","MutationObserver","observe","attributes","attributeFilter","disconnect","trackFormControl","onFieldsetDisabledChange","onFormReset","cleanups","forEach","cleanup","isFrame","tagName","NATURALLY_TABBABLE_REGEX","parseTabIndex","attr","NaN","parseInt","hasTabIndex","Number","isNaN","hasNegativeTabIndex","getShadowRootForNode","getShadowRoot","collectElementsWithShadowDOM","elements","filterFn","allElements","toProcess","processed","positionMap","Map","i","processIndex","shadowElements","focusableSelector","filter","hostIndex","insertPosition","splice","push","getFocusables","includeContainer","include","isFocusable","unshift","focusableElements","contentDocument","frameBody","body","getFirstFocusable","first","getTabbables","isTabbable","tabbableElements","tabIndex","getFirstTabbable","getLastTabbable","getTabbableEdges","last","getNextTabbable","current","tabbables","currentElement","indexOf","getTabIndex","getInitialFocus","getInitialEl","enabled","isValidTabEvent","firstTabbable","lastTabbable","AnimationFrame","_AnimationFrame","cancel","create","request","globalThis","requestAnimationFrame","fn_cleanup","cancelAnimationFrame","isActive","raf","frame","nextTick","raf2","fn2","queueBeforeEvent","cb","cancelTimer","exec","once","capture","observeAttributesImpl","changes","change","attributeName","observeAttributes","nodeOrFn","defer","func","observeChildrenImpl","childList","subtree","observeChildren","navigate","items","loop","isVertical","isHorizontal","isForward","nextIdx","clickIfLink","click","MouseEvent","queueMicrotask","getNearestOverflowAncestor","isOverflowElement","getOverflowAncestors","list","scrollableAncestor","isBody","concat","visualViewport","getElementRect","top","left","bottom","right","innerHeight","innerWidth","isInView","ancestor","ancestorRect","elRect","OVERFLOW_RE","nonOverflowValues","overflow","overflowX","overflowY","display","isScrollable","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollIntoView","rootEl","scrollOptions","getScrollPosition","scrollLeft","scrollTop","scrollX","scrollY","getRelativePoint","offset","percent","getPercentValue","inverted","invertX","invertY","requestPointerLock","supported","isLocked","pointerLockElement","onPointerChange","onPointerError","console","error","exitPointerLock","cleanup2","state","userSelect","elementMap","disableTextSelectionImpl","docNode","style","webkitUserSelect","restoreTextSelection","setTimeout","prevUserSelect","delete","disableTextSelection","restOptions","trackPointerMove","handlers","onPointerMove","onPointerUp","handleMove","distance","sqrt","moveBuffer","handleUp","trackPress","pointerNode","keyboardNode","onPress","onPressStart","onPressEnd","isValidKey","removeStartListeners","removeEndListeners","removeAccessibleListeners","getInfo","startPress","cancelPress","startPointerPress","startEvent","endPointerPress","endEvent","removePointerUpListener","removePointerCancelListener","preventDefault","removePointerListener","removeFocusListener","startAccessiblePress","handleKeydown","keydownEvent","handleKeyup","keyupEvent","evt2","PointerEvent","info","evt","handleBlur","removeKeydownListener","removeBlurListener","proxyTabFocusImpl","triggerElement","onFocus","onFocusEnter","onKeyDown","elementToFocus","nextTabbableAfterTrigger","noTabbableElements","focus","proxyTabFocus","trigger","queryAll","query","defaultItemToId","itemById","itemToId","find","item","indexOfId","nextById","prevById","createSharedResizeObserver","listeners","observer","entries","getObserver","ResizeObserver","observedEntries","entry","elementListeners","listener","elementListeners2","size","unobserve","resizeObserverContentBox","box","resizeObserverBorderBox","resizeObserverDevicePixelContentBox","createScope","methods","dom","ctx","getDoc","getWin","getById","setValue","elem","toString","sanitize","char","code","charCodeAt","replace","trim","getValueText","dataset","valuetext","textContent","match","valueText","query2","toLowerCase","startsWith","getByText","text","currentId","isSingleKey","prev","exists","setProperty","prop","setStyle","keys","getPropertyValue","assign","setStyleProperty","getByTypeaheadImpl","baseItems","state2","activeId","timeout","search","keysSoFar","isRepeated","every","clearTimeout","timer","update","getByTypeahead","defaultOptions","isValidEvent","isValidTypeaheadEvent","trackVisualViewport","onResize","getViewportSize","visuallyHiddenStyle","border","clip","margin","padding","position","whiteSpace","wordWrap","setVisuallyHidden","waitForPromise","promise","signal","wrappedPromise","reject","timeoutId","aborted","catch","abort","waitForElement","AbortController","el2","isConnected"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@zag-js/dom-query/dist/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/caret.ts\nfunction isCaretAtStart(input) {\n  if (!input) return false;\n  try {\n    return input.selectionStart === 0 && input.selectionEnd === 0;\n  } catch {\n    return input.value === \"\";\n  }\n}\nfunction setCaretToEnd(input) {\n  if (!input) return;\n  const start = input.selectionStart ?? 0;\n  const end = input.selectionEnd ?? 0;\n  if (Math.abs(end - start) !== 0) return;\n  if (start !== 0) return;\n  input.setSelectionRange(input.value.length, input.value.length);\n}\n\n// src/shared.ts\nvar clamp = (value) => Math.max(0, Math.min(1, value));\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nvar pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\nvar isObject = (v) => typeof v === \"object\" && v !== null;\nvar MAX_Z_INDEX = 2147483647;\nvar dataAttr = (guard) => guard ? \"\" : void 0;\nvar ariaAttr = (guard) => guard ? \"true\" : void 0;\n\n// src/node.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = (el) => isObject(el) && el === el.window;\nvar isVisualViewport = (el) => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = (node) => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = (el) => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\nvar isInputElement = (el) => isHTMLElement(el) && el.localName === \"input\";\nvar isAnchorElement = (el) => !!el?.matches(\"a[href]\");\nvar isElementVisible = (el) => {\n  if (!isHTMLElement(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n};\nfunction isActiveElement(element) {\n  if (!element) return false;\n  const rootNode = element.getRootNode();\n  return getActiveElement(rootNode) === element;\n}\nvar TEXTAREA_SELECT_REGEX = /(textarea|select)/;\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) return false;\n  try {\n    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute(\"contenteditable\") === \"true\" || el.getAttribute(\"contenteditable\") === \"\";\n  } catch {\n    return false;\n  }\n}\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  const rootNode = child.getRootNode?.();\n  if (parent === child) return true;\n  if (parent.contains(child)) return true;\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) return true;\n      next = next.parentNode || next.host;\n    }\n  }\n  return false;\n}\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(rootNode) {\n  let activeElement = rootNode.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement;\n    if (!el || el === activeElement) break;\n    else activeElement = el;\n  }\n  return activeElement;\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") return node;\n  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getRootNode(node) {\n  let result;\n  try {\n    result = node.getRootNode({ composed: true });\n    if (isDocument(result) || isShadowRoot(result)) return result;\n  } catch {\n  }\n  return node.ownerDocument ?? document;\n}\n\n// src/computed-style.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/controller.ts\nvar INTERACTIVE_CONTAINER_ROLE = /* @__PURE__ */ new Set([\"menu\", \"listbox\", \"dialog\", \"grid\", \"tree\", \"region\"]);\nvar isInteractiveContainerRole = (role) => INTERACTIVE_CONTAINER_ROLE.has(role);\nvar getAriaControls = (element) => element.getAttribute(\"aria-controls\")?.split(\" \") || [];\nfunction isControlledElement(container, element) {\n  const visitedIds = /* @__PURE__ */ new Set();\n  const rootNode = getRootNode(container);\n  const checkElement = (searchRoot) => {\n    const controllingElements = searchRoot.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && isInteractiveContainerRole(role) && !modal) {\n            if (controlledElement === element || controlledElement.contains(element)) {\n              return true;\n            }\n            if (checkElement(controlledElement)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  return checkElement(container);\n}\nfunction findControlledElements(searchRoot, callback) {\n  const rootNode = getRootNode(searchRoot);\n  const visitedIds = /* @__PURE__ */ new Set();\n  const findRecursive = (root) => {\n    const controllingElements = root.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && INTERACTIVE_CONTAINER_ROLE.has(role) && !modal) {\n            callback(controlledElement);\n            findRecursive(controlledElement);\n          }\n        }\n      }\n    }\n  };\n  findRecursive(searchRoot);\n}\nfunction getControlledElements(container) {\n  const controlledElements = /* @__PURE__ */ new Set();\n  findControlledElements(container, (controlledElement) => {\n    if (!container.contains(controlledElement)) {\n      controlledElements.add(controlledElement);\n    }\n  });\n  return Array.from(controlledElements);\n}\nfunction isInteractiveContainerElement(element) {\n  const role = element.getAttribute(\"role\");\n  return Boolean(role && INTERACTIVE_CONTAINER_ROLE.has(role));\n}\nfunction isControllerElement(element) {\n  return element.hasAttribute(\"aria-controls\") && element.getAttribute(\"aria-expanded\") === \"true\";\n}\nfunction hasControllerElements(element) {\n  if (isControllerElement(element)) return true;\n  return Boolean(element.querySelector?.('[aria-controls][aria-expanded=\"true\"]'));\n}\nfunction isControlledByExpandedController(element) {\n  if (!element.id) return false;\n  const rootNode = getRootNode(element);\n  const escapedId = CSS.escape(element.id);\n  const selector = `[aria-controls~=\"${escapedId}\"][aria-expanded=\"true\"], [aria-controls=\"${escapedId}\"][aria-expanded=\"true\"]`;\n  const controller = rootNode.querySelector(selector);\n  return Boolean(controller && isInteractiveContainerElement(element));\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const { type, quality = 0.92, background } = opts;\n  if (!svg) throw new Error(\"[zag-js > getDataUrl]: Could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const svgBounds = svg.getBoundingClientRect();\n  const svgClone = svg.cloneNode(true);\n  if (!svgClone.hasAttribute(\"viewBox\")) {\n    svgClone.setAttribute(\"viewBox\", `0 0 ${svgBounds.width} ${svgBounds.height}`);\n  }\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svgClone);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString).then((str) => {\n      svgClone.remove();\n      return str;\n    });\n  }\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  if (type === \"image/jpeg\" || background) {\n    context.fillStyle = background || \"white\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height);\n      resolve(canvas.toDataURL(type, quality));\n      svgClone.remove();\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nfunction getUserAgent() {\n  const ua2 = navigator.userAgentData;\n  if (ua2 && Array.isArray(ua2.brands)) {\n    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \");\n  }\n  return navigator.userAgent;\n}\nvar pt = (v) => isDom() && v.test(getPlatform());\nvar ua = (v) => isDom() && v.test(getUserAgent());\nvar vn = (v) => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isIPhone = () => pt(/^iPhone/i);\nvar isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;\nvar isIos = () => isIPhone() || isIPad();\nvar isApple = () => isMac() || isIos();\nvar isMac = () => pt(/^Mac/i);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/Firefox/i);\nvar isChrome = () => ua(/Chrome/i);\nvar isWebKit = () => ua(/AppleWebKit/i) && !isChrome();\nvar isAndroid = () => ua(/Android/i);\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget;\n  const data = event.data;\n  return value.slice(0, selectionStart) + (data ?? \"\") + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const validElement = element.matches(\"a[href], button[type='submit'], input[type='submit']\");\n  if (!validElement) return false;\n  const isMiddleClick = event.button === 1;\n  const isModKeyClick = isCtrlOrMetaKey(event);\n  return isMiddleClick || isModKeyClick;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return getNativeEvent(event).isComposing || event.keyCode === 229;\n}\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isCtrlOrMetaKey(e) {\n  if (isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.pointerType === \"\" && e.isTrusted) return true;\n  if (isAndroid() && e.pointerType) {\n    return e.type === \"click\" && e.buttons === 1;\n  }\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = (e) => e.button === 0;\nvar isContextMenuEvent = (e) => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;\nvar isTouchEvent = (event) => \"touches\" in event && event.touches.length > 0;\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options;\n  let key = event.key;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];\n  return key;\n}\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\nvar pageKeys = /* @__PURE__ */ new Set([\"PageUp\", \"PageDown\"]);\nvar arrowKeys = /* @__PURE__ */ new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = pageKeys.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\nfunction getEventPoint(event, type = \"client\") {\n  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n  return { x: point[`${type}X`], y: point[`${type}Y`] };\n}\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\nvar isSelfTarget = (event) => {\n  const composedPath = getComposedPath(event);\n  const target = composedPath?.[0] ?? event.target;\n  return event.currentTarget === target;\n};\n\n// src/form.ts\nfunction getDescriptor(el, options) {\n  const { type = \"HTMLInputElement\", property = \"value\" } = options;\n  const proto = getWindow(el)[type].prototype;\n  return Object.getOwnPropertyDescriptor(proto, property) ?? {};\n}\nfunction getElementType(el) {\n  if (el.localName === \"input\") return \"HTMLInputElement\";\n  if (el.localName === \"textarea\") return \"HTMLTextAreaElement\";\n  if (el.localName === \"select\") return \"HTMLSelectElement\";\n}\nfunction setElementValue(el, value, property = \"value\") {\n  if (!el) return;\n  const type = getElementType(el);\n  if (type) {\n    const descriptor = getDescriptor(el, { type, property });\n    descriptor.set?.call(el, value);\n  }\n  el.setAttribute(property, value);\n}\nfunction setElementChecked(el, checked) {\n  if (!el) return;\n  const descriptor = getDescriptor(el, { type: \"HTMLInputElement\", property: \"checked\" });\n  descriptor.set?.call(el, checked);\n  if (checked) el.setAttribute(\"checked\", \"\");\n  else el.removeAttribute(\"checked\");\n}\nfunction dispatchInputValueEvent(el, options) {\n  const { value, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementValue(el, `${value}`);\n  el.dispatchEvent(new win.Event(\"input\", { bubbles }));\n}\nfunction dispatchInputCheckedEvent(el, options) {\n  const { checked, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementChecked(el, checked);\n  el.dispatchEvent(new win.Event(\"click\", { bubbles }));\n}\nfunction getClosestForm(el) {\n  return isFormElement(el) ? el.form : el.closest(\"form\");\n}\nfunction isFormElement(el) {\n  return el.matches(\"textarea, input, select, button\");\n}\nfunction trackFormReset(el, callback) {\n  if (!el) return;\n  const form = getClosestForm(el);\n  const onReset = (e) => {\n    if (e.defaultPrevented) return;\n    callback();\n  };\n  form?.addEventListener(\"reset\", onReset, { passive: true });\n  return () => form?.removeEventListener(\"reset\", onReset);\n}\nfunction trackFieldsetDisabled(el, callback) {\n  const fieldset = el?.closest(\"fieldset\");\n  if (!fieldset) return;\n  callback(fieldset.disabled);\n  const win = getWindow(fieldset);\n  const obs = new win.MutationObserver(() => callback(fieldset.disabled));\n  obs.observe(fieldset, {\n    attributes: true,\n    attributeFilter: [\"disabled\"]\n  });\n  return () => obs.disconnect();\n}\nfunction trackFormControl(el, options) {\n  if (!el) return;\n  const { onFieldsetDisabledChange, onFormReset } = options;\n  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];\n  return () => cleanups.forEach((cleanup) => cleanup?.());\n}\n\n// src/tabbable.ts\nvar isFrame = (el) => isHTMLElement(el) && el.tagName === \"IFRAME\";\nvar NATURALLY_TABBABLE_REGEX = /^(audio|video|details)$/;\nfunction parseTabIndex(el) {\n  const attr = el.getAttribute(\"tabindex\");\n  if (!attr) return NaN;\n  return parseInt(attr, 10);\n}\nvar hasTabIndex = (el) => !Number.isNaN(parseTabIndex(el));\nvar hasNegativeTabIndex = (el) => parseTabIndex(el) < 0;\nfunction getShadowRootForNode(element, getShadowRoot) {\n  if (!getShadowRoot) return null;\n  if (getShadowRoot === true) {\n    return element.shadowRoot || null;\n  }\n  const result = getShadowRoot(element);\n  return (result === true ? element.shadowRoot : result) || null;\n}\nfunction collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {\n  const allElements = [...elements];\n  const toProcess = [...elements];\n  const processed = /* @__PURE__ */ new Set();\n  const positionMap = /* @__PURE__ */ new Map();\n  elements.forEach((el, i) => positionMap.set(el, i));\n  let processIndex = 0;\n  while (processIndex < toProcess.length) {\n    const element = toProcess[processIndex++];\n    if (!element || processed.has(element)) continue;\n    processed.add(element);\n    const shadowRoot = getShadowRootForNode(element, getShadowRoot);\n    if (shadowRoot) {\n      const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);\n      const hostIndex = positionMap.get(element);\n      if (hostIndex !== void 0) {\n        const insertPosition = hostIndex + 1;\n        allElements.splice(insertPosition, 0, ...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n        for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {\n          positionMap.set(allElements[i], i);\n        }\n      } else {\n        const insertPosition = allElements.length;\n        allElements.push(...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n      }\n      toProcess.push(...shadowElements);\n    }\n  }\n  return allElements;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, options = {}) => {\n  if (!container) return [];\n  const { includeContainer = false, getShadowRoot } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = [];\n  for (const element of elements) {\n    if (!isFocusable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.push(...getFocusables(frameBody, { getShadowRoot }));\n      continue;\n    }\n    focusableElements.push(element);\n  }\n  if (getShadowRoot) {\n    return collectElementsWithShadowDOM(focusableElements, getShadowRoot, isFocusable);\n  }\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!isHTMLElement(element) || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isElementVisible(element);\n}\nfunction getFirstFocusable(container, options = {}) {\n  const [first] = getFocusables(container, options);\n  return first || null;\n}\nfunction getTabbables(container, options = {}) {\n  if (!container) return [];\n  const { includeContainer, getShadowRoot } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  if (includeContainer && isTabbable(container)) {\n    elements.unshift(container);\n  }\n  const tabbableElements = [];\n  for (const element of elements) {\n    if (!isTabbable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      tabbableElements.push(...getTabbables(frameBody, { getShadowRoot }));\n      continue;\n    }\n    tabbableElements.push(element);\n  }\n  if (getShadowRoot) {\n    const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);\n    if (!allElements.length && includeContainer) {\n      return elements;\n    }\n    return allElements;\n  }\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (isHTMLElement(el) && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, options = {}) {\n  const [first] = getTabbables(container, options);\n  return first || null;\n}\nfunction getLastTabbable(container, options = {}) {\n  const elements = getTabbables(container, options);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, options = {}) {\n  const elements = getTabbables(container, options);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, options = {}) {\n  const { current, getShadowRoot } = options;\n  const tabbables = getTabbables(container, { getShadowRoot });\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? getActiveElement(doc);\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\nfunction getTabIndex(node) {\n  if (node.tabIndex < 0) {\n    if ((NATURALLY_TABBABLE_REGEX.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const { root, getInitialEl, filter, enabled = true } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  if (isActiveElement(firstTabbable) && event.shiftKey) return false;\n  if (isActiveElement(lastTabbable) && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/raf.ts\nvar AnimationFrame = class _AnimationFrame {\n  constructor() {\n    __publicField(this, \"id\", null);\n    __publicField(this, \"fn_cleanup\");\n    __publicField(this, \"cleanup\", () => {\n      this.cancel();\n    });\n  }\n  static create() {\n    return new _AnimationFrame();\n  }\n  request(fn) {\n    this.cancel();\n    this.id = globalThis.requestAnimationFrame(() => {\n      this.id = null;\n      this.fn_cleanup = fn?.();\n    });\n  }\n  cancel() {\n    if (this.id !== null) {\n      globalThis.cancelAnimationFrame(this.id);\n      this.id = null;\n    }\n    this.fn_cleanup?.();\n    this.fn_cleanup = void 0;\n  }\n  isActive() {\n    return this.id !== null;\n  }\n};\nfunction raf(fn) {\n  const frame = AnimationFrame.create();\n  frame.request(fn);\n  return frame.cleanup;\n}\nfunction nextTick(fn) {\n  const set = /* @__PURE__ */ new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set.forEach((fn2) => fn2());\n  };\n}\nfunction queueBeforeEvent(el, type, cb) {\n  const cancelTimer = raf(() => {\n    el.removeEventListener(type, exec, true);\n    cb();\n  });\n  const exec = () => {\n    cancelTimer();\n    cb();\n  };\n  el.addEventListener(type, exec, { once: true, capture: true });\n  return cancelTimer;\n}\n\n// src/mutation-observer.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const { attributes, callback: fn } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeAttributesImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\nfunction observeChildrenImpl(node, options) {\n  const { callback: fn } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeChildrenImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/navigate.ts\nfunction navigate(items, current, options = {}) {\n  if (!current) return null;\n  const { orientation = \"both\", loop = true, dir = \"ltr\", key } = options;\n  if (!items.length || !key) return null;\n  const isVertical = key === \"ArrowUp\" || key === \"ArrowDown\";\n  const isHorizontal = key === \"ArrowLeft\" || key === \"ArrowRight\";\n  if (!isVertical && !isHorizontal && key !== \"Home\" && key !== \"End\") return null;\n  if (orientation === \"vertical\" && isHorizontal || orientation === \"horizontal\" && isVertical) return null;\n  if (key === \"Home\") return items[0] || null;\n  if (key === \"End\") return items[items.length - 1] || null;\n  const idx = items.indexOf(current);\n  if (idx === -1) return null;\n  let isForward;\n  if (orientation === \"both\") {\n    isForward = key === \"ArrowDown\" || (dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\");\n  } else {\n    isForward = isVertical ? key === \"ArrowDown\" : dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\";\n  }\n  const nextIdx = isForward ? loop ? (idx + 1) % items.length : Math.min(idx + 1, items.length - 1) : loop ? (idx - 1 + items.length) % items.length : Math.max(0, idx - 1);\n  return items[nextIdx] || null;\n}\nfunction clickIfLink(el) {\n  const click = () => {\n    const win = getWindow(el);\n    el.dispatchEvent(new win.MouseEvent(\"click\"));\n  };\n  if (isFirefox()) {\n    queueBeforeEvent(el, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) return getDocument(parentNode).body;\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getElementRect = (el) => {\n  if (isHTMLElement(el)) return el.getBoundingClientRect();\n  if (isVisualViewport(el)) return { top: 0, left: 0, bottom: el.height, right: el.width };\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getElementRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nvar nonOverflowValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !nonOverflowValues.has(display);\n}\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const { rootEl, ...scrollOptions } = options || {};\n  if (!el || !rootEl) return;\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;\n  el.scrollIntoView(scrollOptions);\n}\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };\n}\n\n// src/point.ts\nfunction getRelativePoint(point, element) {\n  const { left, top, width, height } = element.getBoundingClientRect();\n  const offset = { x: point.x - left, y: point.y - top };\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };\n  function getPercentValue(options = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return { offset, percent, getPercentValue };\n}\n\n// src/pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occurred:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {\n  }\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ];\n  return () => {\n    cleanup.forEach((cleanup2) => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/text-selection.ts\nvar state = \"default\";\nvar userSelect = \"\";\nvar elementMap = /* @__PURE__ */ new WeakMap();\nfunction disableTextSelectionImpl(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect;\n      rootEl.style.webkitUserSelect = \"none\";\n    }\n    state = \"disabled\";\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n  return () => restoreTextSelection({ target, doc: docNode });\n}\nfunction restoreTextSelection(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state !== \"disabled\") return;\n    state = \"restoring\";\n    setTimeout(() => {\n      nextTick(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\";\n          }\n          userSelect = \"\";\n          state = \"default\";\n        }\n      });\n    }, 300);\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target);\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\";\n      }\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\");\n      }\n      elementMap.delete(target);\n    }\n  }\n}\nfunction disableTextSelection(options = {}) {\n  const { defer, target, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof target === \"function\" ? target() : target;\n      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/pointer-move.ts\nfunction trackPointerMove(doc, handlers) {\n  const { onPointerMove, onPointerUp } = handlers;\n  const handleMove = (event) => {\n    const point = getEventPoint(event);\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.buttons === 0) {\n      handleUp(event);\n      return;\n    }\n    onPointerMove({ point, event });\n  };\n  const handleUp = (event) => {\n    const point = getEventPoint(event);\n    onPointerUp({ point, event });\n  };\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", handleUp, false),\n    addDomEvent(doc, \"pointercancel\", handleUp, false),\n    addDomEvent(doc, \"contextmenu\", handleUp, false),\n    disableTextSelection({ doc })\n  ];\n  return () => {\n    cleanups.forEach((cleanup) => cleanup());\n  };\n}\n\n// src/press.ts\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = (event) => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = (startEvent) => {\n    removeEndListeners();\n    const endPointerPress = (endEvent) => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress, once: true });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd,\n      once: true\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (isActiveElement(keyboardNode) && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent) => {\n      if (!isValidKey(keydownEvent)) return;\n      const handleKeyup = (keyupEvent) => {\n        if (!isValidKey(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return () => {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const { triggerElement, onFocus, onFocusEnter, getShadowRoot } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, { includeContainer: true, getShadowRoot });\n    const nextTabbableAfterTrigger = getNextTabbable(body, { current: triggerElement, getShadowRoot });\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && isActiveElement(nextTabbableAfterTrigger)) {\n      onFocusEnter?.();\n      elementToFocus = lastTabbable;\n    } else if (event.shiftKey && (isActiveElement(firstTabbable) || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && isActiveElement(triggerElement)) {\n      onFocusEnter?.();\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (isActiveElement(lastTabbable) || noTabbableElements)) {\n      elementToFocus = nextTabbableAfterTrigger;\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  return addDomEvent(doc, \"keydown\", onKeyDown, true);\n}\nfunction proxyTabFocus(container, options) {\n  const { defer, triggerElement, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container;\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\nvar defaultItemToId = (v) => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/resize-observer.ts\nfunction createSharedResizeObserver(options) {\n  const listeners = /* @__PURE__ */ new WeakMap();\n  let observer;\n  const entries = /* @__PURE__ */ new WeakMap();\n  const getObserver = (win) => {\n    if (observer) return observer;\n    observer = new win.ResizeObserver((observedEntries) => {\n      for (const entry of observedEntries) {\n        entries.set(entry.target, entry);\n        const elementListeners = listeners.get(entry.target);\n        if (elementListeners) {\n          for (const listener of elementListeners) {\n            listener(entry);\n          }\n        }\n      }\n    });\n    return observer;\n  };\n  const observe = (element, listener) => {\n    let elementListeners = listeners.get(element) || /* @__PURE__ */ new Set();\n    elementListeners.add(listener);\n    listeners.set(element, elementListeners);\n    const win = getWindow(element);\n    getObserver(win).observe(element, options);\n    return () => {\n      const elementListeners2 = listeners.get(element);\n      if (!elementListeners2) return;\n      elementListeners2.delete(listener);\n      if (elementListeners2.size === 0) {\n        listeners.delete(element);\n        getObserver(win).unobserve(element);\n      }\n    };\n  };\n  const unobserve = (element) => {\n    listeners.delete(element);\n    observer?.unobserve(element);\n  };\n  return {\n    observe,\n    unobserve\n  };\n}\nvar resizeObserverContentBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"content-box\"\n});\nvar resizeObserverBorderBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"border-box\"\n});\nvar resizeObserverDevicePixelContentBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"device-pixel-content-box\"\n});\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,\n    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx) => getActiveElement(dom.getRootNode(ctx)),\n    isActiveElement,\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      setElementValue(elem, value.toString());\n    }\n  };\n  return { ...dom, ...methods };\n}\n\n// src/searchable.ts\nvar sanitize = (str) => str.split(\"\").map((char) => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\nvar getValueText = (el) => {\n  return sanitize(el.dataset?.valuetext ?? el.textContent ?? \"\");\n};\nvar match = (valueText, query2) => {\n  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId);\n  }\n  return items.find((item) => match(getValueText(item), text));\n}\n\n// src/set.ts\nfunction setAttribute(el, attr, v) {\n  const prev = el.getAttribute(attr);\n  const exists = prev != null;\n  el.setAttribute(attr, v);\n  return () => {\n    if (!exists) {\n      el.removeAttribute(attr);\n    } else {\n      el.setAttribute(attr, prev);\n    }\n  };\n}\nfunction setProperty(el, prop, v) {\n  const exists = prop in el;\n  const prev = el[prop];\n  el[prop] = v;\n  return () => {\n    if (!exists) {\n      delete el[prop];\n    } else {\n      el[prop] = prev;\n    }\n  };\n}\nfunction setStyle(el, style) {\n  if (!el) return noop;\n  const prev = Object.keys(style).reduce((acc, key) => {\n    acc[key] = el.style.getPropertyValue(key);\n    return acc;\n  }, {});\n  Object.assign(el.style, style);\n  return () => {\n    Object.assign(el.style, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\nfunction setStyleProperty(el, prop, value) {\n  if (!el) return noop;\n  const prev = el.style.getPropertyValue(prop);\n  el.style.setProperty(prop, value);\n  return () => {\n    el.style.setProperty(prop, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\n\n// src/typeahead.ts\nfunction getByTypeaheadImpl(baseItems, options) {\n  const { state: state2, activeId, key, timeout = 350, itemToId } = options;\n  const search = state2.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = baseItems.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state2.timer);\n    state2.timer = -1;\n  }\n  function update(value) {\n    state2.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state2.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\nfunction setVisuallyHidden(el) {\n  Object.assign(el.style, visuallyHiddenStyle);\n}\n\n// src/wait-for.ts\nfunction waitForPromise(promise, controller, timeout) {\n  const { signal } = controller;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Timeout of ${timeout}ms exceeded`));\n    }, timeout);\n    signal.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(new Error(\"Promise aborted\"));\n    });\n    promise.then((result) => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    }).catch((error) => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  });\n  const abort = () => controller.abort();\n  return [wrappedPromise, abort];\n}\nfunction waitForElement(target, options) {\n  const { timeout, rootNode } = options;\n  const win = getWindow(rootNode);\n  const doc = getDocument(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(\n    new Promise((resolve) => {\n      const el = target();\n      if (el) {\n        resolve(el);\n        return;\n      }\n      const observer = new win.MutationObserver(() => {\n        const el2 = target();\n        if (el2 && el2.isConnected) {\n          observer.disconnect();\n          resolve(el2);\n        }\n      });\n      observer.observe(doc.body, {\n        childList: true,\n        subtree: true\n      });\n    }),\n    controller,\n    timeout\n  );\n}\n\nexport { AnimationFrame, MAX_Z_INDEX, addDomEvent, ariaAttr, clickIfLink, contains, createScope, dataAttr, defaultItemToId, disableTextSelection, dispatchInputCheckedEvent, dispatchInputValueEvent, findControlledElements, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getControlledElements, getDataUrl, getDocument, getDocumentElement, getEventKey, getEventPoint, getEventStep, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNativeEvent, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getRelativePoint, getRootNode, getScrollPosition, getTabIndex, getTabbableEdges, getTabbables, getUserAgent, getWindow, hasControllerElements, indexOfId, isActiveElement, isAnchorElement, isAndroid, isApple, isCaretAtStart, isChrome, isComposingEvent, isContextMenuEvent, isControlledByExpandedController, isControlledElement, isControllerElement, isCtrlOrMetaKey, isDocument, isDom, isDownloadingEvent, isEditableElement, isElementVisible, isFirefox, isFocusable, isHTMLElement, isIPad, isIPhone, isInView, isInputElement, isInteractiveContainerElement, isIos, isKeyboardClick, isLeftClick, isMac, isModifierKey, isNode, isOpeningInNewTab, isOverflowElement, isPrintableKey, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isTouchEvent, isValidTabEvent, isVirtualClick, isVirtualPointerEvent, isVisualViewport, isWebKit, isWindow, itemById, navigate, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, queueBeforeEvent, raf, requestPointerLock, resizeObserverBorderBox, resizeObserverContentBox, resizeObserverDevicePixelContentBox, restoreTextSelection, scrollIntoView, setAttribute, setCaretToEnd, setElementChecked, setElementValue, setProperty, setStyle, setStyleProperty, setVisuallyHidden, trackFormControl, trackPointerMove, trackPress, trackVisualViewport, visuallyHiddenStyle, waitForElement, waitForPromise };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}