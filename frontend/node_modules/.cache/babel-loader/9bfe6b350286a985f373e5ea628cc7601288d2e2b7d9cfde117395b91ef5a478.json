{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, isLeftClick, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\", \"resizeTriggerIndicator\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = ctx => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = ctx => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = ctx => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = panels.findIndex(panel => panel.id === afterId);\n  const {\n    valueMax,\n    valueMin,\n    valueNow\n  } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find(panel2 => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex(prevPanel => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex(panel => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return {\n    ...panel,\n    panelSize,\n    pivotIndices\n  };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map(panel => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map(panel => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map(key => {\n    const panel = panels.find(panel2 => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({\n  panels,\n  size: sizes\n}) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const orientation = prop(\"orientation\");\n  const getPanelStyle = id => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex(panel => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  const getResizeTriggerState = props2 => {\n    const {\n      id,\n      disabled\n    } = props2;\n    const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n    const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n    return {\n      dragging: dragging2,\n      focused,\n      disabled: !!disabled\n    };\n  };\n  return {\n    dragging,\n    orientation,\n    getPanels() {\n      return prop(\"panels\");\n    },\n    getPanelById(id) {\n      return getPanelById(prop(\"panels\"), id);\n    },\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [{\n            type: \"panel\",\n            id: panel.id\n          }, {\n            type: \"handle\",\n            id: `${panel.id}:${nextPanel.id}`\n          }];\n        }\n        return [{\n          type: \"panel\",\n          id: panel.id\n        }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({\n        type: \"SIZE.SET\",\n        size\n      });\n    },\n    resetSizes() {\n      send({\n        type: \"SIZE.SET\",\n        size: context.initial(\"size\")\n      });\n    },\n    collapsePanel(id) {\n      send({\n        type: \"PANEL.COLLAPSE\",\n        id\n      });\n    },\n    expandPanel(id, minSize) {\n      send({\n        type: \"PANEL.EXPAND\",\n        id,\n        minSize\n      });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({\n        type: \"PANEL.RESIZE\",\n        id,\n        size: unsafePanelSize\n      });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": orientation,\n        \"data-dragging\": dataAttr(dragging),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": orientation,\n        \"data-dragging\": dataAttr(dragging),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerState,\n    getResizeTriggerIndicator(props2) {\n      const triggerState = getResizeTriggerState(props2);\n      return normalize.element({\n        ...parts.resizeTriggerIndicator.attrs,\n        \"data-orientation\": orientation,\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"data-dragging\": dataAttr(triggerState.dragging),\n        \"data-disabled\": dataAttr(triggerState.disabled),\n        \"data-ownedby\": getRootId(scope)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const {\n        id\n      } = props2;\n      const triggerState = getResizeTriggerState(props2);\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: triggerState.disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": orientation,\n        \"aria-orientation\": orientation,\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"data-dragging\": dataAttr(triggerState.dragging),\n        \"data-disabled\": dataAttr(triggerState.disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: triggerState.disabled ? \"none\" : triggerState.dragging && !triggerState.focused ? \"none\" : void 0,\n          cursor: triggerState.disabled ? void 0 : horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (!isLeftClick(event)) return;\n          if (triggerState.disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            id,\n            point\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (triggerState.disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (triggerState.disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (triggerState.disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          if (triggerState.disabled) return;\n          send({\n            type: \"BLUR\"\n          });\n        },\n        onFocus() {\n          if (triggerState.disabled) return;\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (triggerState.disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"ENTER\",\n                id\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : -delta\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? -delta : 0\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? delta : 0\n              });\n            },\n            Home() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: -100\n              });\n            },\n            End() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: 100\n              });\n            },\n            F6() {\n              send({\n                type: \"FOCUS.CYCLE\",\n                id,\n                shiftKey: event.shiftKey\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({\n  panels,\n  index,\n  size\n}) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let {\n    delta,\n    initialSize,\n    panels,\n    pivotIndices,\n    prevSize,\n    trigger\n  } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({\n      panels,\n      index: pivotIndex,\n      size: unsafeSize\n    });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({\n          panels,\n          index,\n          size: unsafeSize2\n        });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({\n  size: prevSize,\n  panels\n}) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({\n      panels,\n      index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext,\n    getRefs\n  }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */new Map()\n    };\n  },\n  computed: {\n    horizontal({\n      prop\n    }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  exit: [\"clearGlobalCursor\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({\n        send\n      }) => {\n        return setRafTimeout(() => {\n          send({\n            type: \"HOVER_DELAY\"\n          });\n        }, 250);\n      },\n      trackPointerMove: ({\n        scope,\n        send\n      }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({\n        context,\n        prop\n      }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({\n        context\n      }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({\n        context,\n        event\n      }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({\n        context\n      }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const {\n          context,\n          prop,\n          event\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const {\n          panelSize,\n          pivotIndices\n        } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const {\n          context,\n          event,\n          prop,\n          scope\n        } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const {\n          resizeTriggerId,\n          initialSize,\n          initialCursorPosition\n        } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panels.findIndex(panel => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panelDataArray.findIndex(panelData => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({\n        context,\n        prop\n      }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({\n        prop\n      }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex(panelData2 => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(id => panelDataArray.findIndex(panelData2 => panelData2.id === id));\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({\n        context,\n        scope,\n        prop\n      }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex(panel2 => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = {\n          isAtMin,\n          isAtMax\n        };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({\n        scope\n      }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({\n        event,\n        scope\n      }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex(el => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const {\n    refs,\n    prop,\n    context\n  } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const {\n      collapsedSize = 0,\n      collapsible,\n      id: panelId\n    } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({\n            panelId,\n            size\n          });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({\n            panelId,\n            size\n          });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onResize\", \"onResizeStart\", \"onResizeEnd\", \"onCollapse\", \"onExpand\", \"orientation\", \"size\", \"defaultSize\", \"panels\", \"keyboardResizeBy\", \"nonce\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","queryAll","dataAttr","getEventKey","isLeftClick","getEventPoint","prev","next","ensure","isEqual","setRafTimeout","ensureProps","createSplitProps","createMachine","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getResizeTriggerId","resizeTrigger","getPanelId","panel","getGlobalCursorId","getRootEl","getById","getResizeTriggerEl","getCursor","state","x","cursor","isAtMin","isAtMax","getResizeTriggerEls","CSS","escape","setupGlobalCursor","nonce","styleEl","textContent","style","getDoc","createElement","head","appendChild","removeGlobalCursor","remove","calculateAriaValues","size","panels","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","forEach","index","maxSize","minSize","valueMax","Math","min","valueMin","max","valueNow","getAriaValue","handleId","beforeId","afterId","split","beforeIndex","findIndex","afterIndex","round","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","toFixed","fuzzyNumbersEqual","fuzzySizeEqual","length","actualSize","expectedSize","getPanelById","find","panel2","findPanelDataIndex","prevPanel","findPanelIndex","panelDataHelper","sizes","panelSize","sortPanels","sort","panelA","panelB","orderA","order","orderB","getPanelLayout","map","join","serializePanels","keys","sortedKeys","serialized","key","JSON","stringify","getPanelFlexBoxStyle","defaultSize","dragState","panelIndex","precision","flexGrow","toPrecision","flexBasis","flexShrink","overflow","pointerEvents","getUnsafeDefaultSize","finalSizes","Array","numPanelsWithSizes","remainingSize","numRemainingPanels","connect","service","normalize","send","prop","computed","context","scope","horizontal","dragging","matches","orientation","getPanelStyle","initial","get","getResizeTriggerState","props2","disabled","dragging2","resizeTriggerId","focused","getPanels","getItems","flatMap","arr","nextPanel","type","getSizes","setSizes","resetSizes","collapsePanel","expandPanel","resizePanel","unsafePanelSize","getPanelSize","panelData","isPanelCollapsed","collapsedSize","collapsible","isPanelExpanded","getLayout","getRootProps","element","attrs","dir","display","flexDirection","height","width","getPanelProps","getResizeTriggerIndicator","triggerState","resizeTriggerIndicator","getResizeTriggerProps","aria","role","tabIndex","touchAction","userSelect","WebkitUserSelect","flex","onPointerDown","event","preventDefault","point","currentTarget","setPointerCapture","pointerId","stopPropagation","onPointerUp","hasPointerCapture","releasePointerCapture","onPointerOver","onPointerLeave","onBlur","onFocus","onKeyDown","defaultPrevented","keyboardResizeBy","delta","shiftKey","keyMap","Enter","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Home","End","F6","exec","halfwayPoint","parseFloat","resizeByDelta","initialSize","prevSize","trigger","nextSize","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize2","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","delta2","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","localeCompare","numeric","pivotIndex2","prevSize3","unsafeSize2","safeSize2","totalSize","reduce","total","validateSizes","nextSizeTotalSize","accumulated","current","Error","machine","props","initialState","bindable","getContext","getRefs","value","defaultValue","a","b","onChange","refs","sizesBeforeCollapse","expandToSizes","Object","fromEntries","entries","layout","keyboardState","watch","track","action","panelSizeBeforeCollapse","Map","prevDelta","panelIdToLastNotifiedSizeMap","on","actions","entry","exit","states","idle","POINTER_OVER","target","FOCUS","POINTER_DOWN","effects","HOVER_DELAY","POINTER_LEAVE","hover","tags","BLUR","ENTER","KEYBOARD_MOVE","POINTER_MOVE","POINTER_UP","implementations","waitForHoverDelay","doc","onPointerMove","info","setSize","params","syncSize","set","setDraggingState","panelGroupEl","handleElement","initialCursorPosition","y","resizeTriggerRect","getBoundingClientRect","clearDraggingState","setKeyboardState","clearKeyboardState","isLastPanel","minSizeFromProps","prevPanelSize","baseSize","setPointerValue","panelGroupElement","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","offsetPercentage","setKeyboardValue","panelDataArray","invokeOnResizeEnd","queueMicrotask","invokeOnResizeStart","collapseOrExpandPanel","idBefore","idAfter","panelData2","setGlobalCursor","indexBefore","cursorState","clearGlobalCursor","focusNextResizeTrigger","resizeTriggers","el","dataset","handleEl","focus","panelsArray","onCollapse","onExpand","panelId","lastNotifiedSize","splitProps","panelProps","splitPanelProps","resizeTriggerProps","splitResizeTriggerProps"],"sources":["D:/ML AI321- FALL 25/ML_PROJECT_HEALTHCARE_AAAHH/frontend/node_modules/@zag-js/splitter/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, isLeftClick, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\", \"resizeTriggerIndicator\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = (ctx) => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = (ctx) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const { maxSize = 100, minSize = 0 } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);\n  const afterIndex = panels.findIndex((panel) => panel.id === afterId);\n  const { valueMax, valueMin, valueNow } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find((panel2) => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex((prevPanel) => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex((panel) => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return { ...panel, panelSize, pivotIndices };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map((panel) => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map((panel) => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map((key) => {\n    const panel = panels.find((panel2) => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({ panels, size: sizes }) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, prop, computed, context, scope } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const orientation = prop(\"orientation\");\n  const getPanelStyle = (id) => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex((panel) => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  const getResizeTriggerState = (props2) => {\n    const { id, disabled } = props2;\n    const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n    const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n    return {\n      dragging: dragging2,\n      focused,\n      disabled: !!disabled\n    };\n  };\n  return {\n    dragging,\n    orientation,\n    getPanels() {\n      return prop(\"panels\");\n    },\n    getPanelById(id) {\n      return getPanelById(prop(\"panels\"), id);\n    },\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [\n            { type: \"panel\", id: panel.id },\n            { type: \"handle\", id: `${panel.id}:${nextPanel.id}` }\n          ];\n        }\n        return [{ type: \"panel\", id: panel.id }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({ type: \"SIZE.SET\", size });\n    },\n    resetSizes() {\n      send({ type: \"SIZE.SET\", size: context.initial(\"size\") });\n    },\n    collapsePanel(id) {\n      send({ type: \"PANEL.COLLAPSE\", id });\n    },\n    expandPanel(id, minSize) {\n      send({ type: \"PANEL.EXPAND\", id, minSize });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({ type: \"PANEL.RESIZE\", id, size: unsafePanelSize });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": orientation,\n        \"data-dragging\": dataAttr(dragging),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const { id } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": orientation,\n        \"data-dragging\": dataAttr(dragging),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerState,\n    getResizeTriggerIndicator(props2) {\n      const triggerState = getResizeTriggerState(props2);\n      return normalize.element({\n        ...parts.resizeTriggerIndicator.attrs,\n        \"data-orientation\": orientation,\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"data-dragging\": dataAttr(triggerState.dragging),\n        \"data-disabled\": dataAttr(triggerState.disabled),\n        \"data-ownedby\": getRootId(scope)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const { id } = props2;\n      const triggerState = getResizeTriggerState(props2);\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: triggerState.disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": orientation,\n        \"aria-orientation\": orientation,\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(triggerState.focused),\n        \"data-dragging\": dataAttr(triggerState.dragging),\n        \"data-disabled\": dataAttr(triggerState.disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: triggerState.disabled ? \"none\" : triggerState.dragging && !triggerState.focused ? \"none\" : void 0,\n          cursor: triggerState.disabled ? void 0 : horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (!isLeftClick(event)) return;\n          if (triggerState.disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", id, point });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (triggerState.disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (triggerState.disabled) return;\n          send({ type: \"POINTER_OVER\", id });\n        },\n        onPointerLeave() {\n          if (triggerState.disabled) return;\n          send({ type: \"POINTER_LEAVE\", id });\n        },\n        onBlur() {\n          if (triggerState.disabled) return;\n          send({ type: \"BLUR\" });\n        },\n        onFocus() {\n          if (triggerState.disabled) return;\n          send({ type: \"FOCUS\", id });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (triggerState.disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({ type: \"ENTER\", id });\n            },\n            ArrowUp() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : -delta });\n            },\n            ArrowDown() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : delta });\n            },\n            ArrowLeft() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? -delta : 0 });\n            },\n            ArrowRight() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? delta : 0 });\n            },\n            Home() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: -100 });\n            },\n            End() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: 100 });\n            },\n            F6() {\n              send({ type: \"FOCUS.CYCLE\", id, shiftKey: event.shiftKey });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({ panels, index, size }) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let { delta, initialSize, panels, pivotIndices, prevSize, trigger } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({ panels, index: pivotIndex, size: unsafeSize });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({ panels, index, size: unsafeSize2 });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({ size: prevSize, panels }) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map((size) => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({ panels, index, size: unsafeSize });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({ prop, bindable, getContext, getRefs }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({ track, action, prop }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */ new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */ new Map()\n    };\n  },\n  computed: {\n    horizontal({ prop }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  exit: [\"clearGlobalCursor\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({ send }) => {\n        return setRafTimeout(() => {\n          send({ type: \"HOVER_DELAY\" });\n        }, 250);\n      },\n      trackPointerMove: ({ scope, send }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({ type: \"POINTER_MOVE\", point: info.point });\n          },\n          onPointerUp() {\n            send({ type: \"POINTER_UP\" });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const { context, event, prop } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({ context, prop }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({ context, event, prop, scope }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({ context }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({ context, event }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({ context }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const { context, prop, event, refs } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const { context, prop, event, refs } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const { context, prop, event } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const { panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const { context, event, prop, scope } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const { resizeTriggerId, initialSize, initialCursorPosition } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panels.findIndex((panel) => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const { context, event, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panelDataArray.findIndex((panelData) => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({ context, prop }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({ prop }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const { context, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex((panelData2) => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(\n            (id) => panelDataArray.findIndex((panelData2) => panelData2.id === id)\n          );\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({ context, scope, prop }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex((panel2) => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = { isAtMin, isAtMax };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({ scope }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({ event, scope }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex((el) => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const { refs, prop, context } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const { collapsedSize = 0, collapsible, id: panelId } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({ panelId, size });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({ panelId, size });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"onResize\",\n  \"onResizeStart\",\n  \"onResizeEnd\",\n  \"onCollapse\",\n  \"onExpand\",\n  \"orientation\",\n  \"size\",\n  \"defaultSize\",\n  \"panels\",\n  \"keyboardResizeBy\",\n  \"nonce\"\n]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\n\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}